{"uid":"dlang-json-serialiser-1","html":"\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eHave you ever wondered about how serialisers (or other pieces of code) perform their 'magic'? Are you someone\nwho wants to learn how to perform such seemingly arcane feats yourself? Or are you simply someone who wants to learn more about D?\u003c/p\u003e\n\u003cp\u003eRegardless of your reason for being here, with the power of D I'll be taking you through the steps of creating a basic\nJSON Serialiser that uses compile-time introspection/reflection to serialise any random object!\u003c/p\u003e\n\u003cp\u003eTo achieve this, we'll be using one of D's most powerful features: \u003ca href=\"https://tour.dlang.org/tour/en/gems/template-meta-programming\"\u003emetaprogramming\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThis series is aimed towards people who are new/interested in D, while its purpose is to teach and\nshow off different aspects of D's metaprogramming features, ending with the creation of a semi-useful serialiser/deserialiser for JSON.\u003c/p\u003e\n\u003cp\u003eThis first post will cover the creation of two template functions, which, as the series progresses, will\nbegin to use a broad range of D's meta programming features to determine how to serialise/deserialise most of D's primitive types.\u003c/p\u003e\n\u003cp\u003eSome code snippets may start with a comment containing a link to \u003ca href=\"https://run.dlang.io/\"\u003ehttps://run.dlang.io/\u003c/a\u003e\nwhich will take you to an online D environment containing a runnable version of that snippet.\u003c/p\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe ability to write and compile D code\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA basic understanding of what a template is (in any language)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA \u003cdel\u003erubber ducky\u003c/del\u003e \u003ca href=\"https://dlang.org/images/dman-rain.jpg\"\u003eD man\u003c/a\u003e close by.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"stdjson\"\u003estd.json\u003c/h2\u003e\n\u003cp\u003eTo make these examples as frictionless to compile as possible, the code will only use\n\u003ca href=\"https://dlang.org/phobos/\"\u003ePhobos\u003c/a\u003e, D's standard library, which luckily for us\nincludes a (rather outdated) JSON module called std.json\u003c/p\u003e\n\u003ch2 id=\"what-are-the-primitive-types\"\u003eWhat are the primitive types?\u003c/h2\u003e\n\u003cp\u003eFor the context of this blog series, a primitive type is type built into the language itself.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIntegers: \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, including their unsigned versions (ubyte, ushort, etc.)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFloating point: \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e, and \u003ccode\u003ereal\u003c/code\u003e (which we won't bother with)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBooleans: \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eStrings\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThere are also chars, but in D they're UTF8 code units which are a bit weird to handle, so I'm just going to ignore them.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"serialising-primitive-types\"\u003eSerialising primitive types\u003c/h2\u003e\n\u003cp\u003eTo start off let's begin with a simple D file that contains an empty main function, and imports std.json;:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003eimport std.json;\n\nvoid main()\n{\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext we want to create a basic template function called \u003ccode\u003eserialise\u003c/code\u003e.\nThis function will take a template parameter of any type (\u003ccode\u003eT\u003c/code\u003e),\nand returns a std.json#JSONValue which is the main struct that std.json uses to represent JSON values.\u003c/p\u003e\n\u003cp\u003eOne of the interesting things about std.json#JSONValue is that its constructor is also a template,\nwhich conveniently supports being able to automatically wrap around any primitive type (and more) that D has.\u003c/p\u003e\n\u003cp\u003eThis means that to serialise a primitive type all we must do is construct a std.json#JSONValue\nand pass our primitive value directly to it.\nDon't think things are this convenient later down the road though.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003eJSONValue serialise(T)(T value)\n{\n    return JSONValue(value);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd it can be used like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003e// run.dlang.io/is/0pBFdu\nvoid main()\n{\n    import std.stdio : writeln;\n\n    JSONValue json;\n\n    // Here we use `!int` to directly specify that `T` is of type `int`.\n    json = serialise!int(420);\n    writeln(json); // 420\n\n    // However, the compiler can actually infer what `T` is based off of the parameters we pass through.\n    // So here, `T` would be `string`.\n    json = serialise(\u0026quot;Hello world!\u0026quot;);\n    writeln(json); // \u0026quot;Hello world!\u0026quot;, including the quotes.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSimple enough, however right now we're letting the user pass through any type they want into our \u003ccode\u003eserialise\u003c/code\u003e function,\nbut we would like to distinguish between primitive types and any other future types we may want to handle such as structs,\nclasses, and enums, all of which are unable to be serialised directly by std.json#JSONValue:JSONValue's constructor.\u003c/p\u003e\n\u003cp\u003e\u0026quot;How do we do this?\u0026quot; you may ask. The answer is \u003ccode\u003estatic if\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"static-if\"\u003eStatic if\u003c/h2\u003e\n\u003cp\u003eIf you're familiar with C++'s \u003ccode\u003e#if\u003c/code\u003e directive\nthen \u003ccode\u003estatic if\u003c/code\u003e should make you feel right at home (without all the downsides of \u003ccode\u003e#if\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estatic if\u003c/code\u003e is like a normal \u003ccode\u003eif\u003c/code\u003e statement, except:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIt only runs at compile time, so its condition must also be able to be evaluated at compile time.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIt doesn't create a new scope.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAny code that isn't inside a \u003ccode\u003estatic if\u003c/code\u003e's passing block (either the \u003ccode\u003eif\u003c/code\u003e or the \u003ccode\u003eelse\u003c/code\u003e) will be ignored by the compiler (outside of syntax checks).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, say I wanted to have a compile time flag in my code that determined whether my program performs logging,\n\u003ccode\u003estatic if\u003c/code\u003e could be used in this situation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003e// https://run.dlang.io/is/yjxGYT\nconst bool SHOULD_LOG = true; // This value is readable at compile time, so can be used in static if.\n\nvoid main()\n{\n    import std.stdio : writeln;\n\n    static if(SHOULD_LOG)\n    {\n        writeln(\u0026quot;This is a log!\u0026quot;);\n    }\n\n    writeln(\u0026quot;Done Task.\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf \u003ccode\u003eSHOULD_LOG\u003c/code\u003e is true then the line \u003ccode\u003ewriteln(\u0026quot;This is a log!\u0026quot;)\u003c/code\u003e is compiled into the program, otherwise\neverything inside of the \u003ccode\u003estatic if\u003c/code\u003e is ignored by the compiler.\u003c/p\u003e\n\u003ch2 id=\"deserialising-primitive-types\"\u003eDeserialising primitive types\u003c/h2\u003e\n\u003cp\u003eNow that we know how \u003ccode\u003estatic if\u003c/code\u003e works we can move onto deserialising primitive types,\nas it's less straight forward than serialising them.\u003c/p\u003e\n\u003cp\u003eTo start, we'll make a deserialise function that takes a std.json#JSONValue, a type parameter (\u003ccode\u003eT\u003c/code\u003e), and returns a \u003ccode\u003eT\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003e// The `T` can be passed by doing `deserialise!int(someJsonValue)`, where `T` would then be `int`.\nT deserialise(T)(JSONValue json)\n{\n    assert(false, \u0026quot;Not implemented\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, converting a std.json#JSONValue back into primitive values isn't as convenient as the other way around\n(edit: this was written before std.json#JSONValue.get was added).\u003c/p\u003e\n\u003cp\u003eInstead, std.json#JSONValue has specific functions for converting back into different types:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003estd.json#JSONValue.str - Convert to a string\u003c/li\u003e\n\u003cli\u003estd.json#JSONValue.integer - Convert to a long\u003c/li\u003e\n\u003cli\u003estd.json#JSONValue.uinteger - Convert to a ulong\u003c/li\u003e\n\u003cli\u003estd.json#JSONValue.floating - Convert to a double\u003c/li\u003e\n\u003cli\u003estd.json#JSONValue.boolean - Convert to a bool\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis means we have to use static if to determine which of the correct functions to call.\nIt should be noted that if for example, you tried to convert a std.json#JSONValue containing a string into a long then an error would be thrown,\nmaking it mandatory that the right function is called.\u003c/p\u003e\n\u003ch3 id=\"deserialisation---is-expression\"\u003eDeserialisation - is() expression\u003c/h3\u003e\n\u003cp\u003eLet's start off with strings. There is an expression in D called the \u003ccode\u003eis()\u003c/code\u003e expression, which has some very magical features\nbut the most basic one is to compare one type to another.\u003c/p\u003e\n\u003cp\u003eI feel this is best shown by example, so let's use \u003ccode\u003estatic if\u003c/code\u003e and \u003ccode\u003eis()\u003c/code\u003e together to determine if our type parameter (\u003ccode\u003eT\u003c/code\u003e) is a string,\nand then call std.json#JSONValue.str;.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003eT deserialise(T)(JSONValue json)\n{\n    // Yea, it's actually that easy.\n    static if(is(T == string))\n    {\n        return json.str;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne particular issue we have though is that with our current code things like \u003ccode\u003edeserialise!string(JSONValue(\u0026quot;Hello world!\u0026quot;))\u003c/code\u003e would work,\nhowever if we were to do something such as \u003ccode\u003edeserialise!int\u003c/code\u003e, which we currently don't have code to handle, we'd get a compiler error\ncomplaining that there's no return value (since the static if doesn't compile a return statement in that case).\u003c/p\u003e\n\u003cp\u003eWhat if we could create our own error messages for a more user friendly experience? In comes \u003ccode\u003estatic assert\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"deserialisation---static-assert\"\u003eDeserialisation - static assert\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003estatic assert\u003c/code\u003e is a compile time version of \u003ccode\u003eassert\u003c/code\u003e (requires a condition that must be true otherwise crash the program),\nthat instead of crashing the program if its condition fails it will instead fail compliation,\noptionally displaying a user-defined message.\u003c/p\u003e\n\u003cp\u003eIn the event that all of our \u003ccode\u003estatic if\u003c/code\u003es fail to have their conditions met, we can then fall back to a\n\u003ccode\u003estatic assert\u003c/code\u003e that prints a user friendly message.\u003c/p\u003e\n\u003cp\u003eWe can use the special \u003ccode\u003e.stringof\u003c/code\u003e property every type has to get a human readable string of whatever type \u003ccode\u003eT\u003c/code\u003e currently is.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003e// https://run.dlang.io/is/nd2LYl\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    {\n        return json.str;\n    }\n    else\n    {\n        static assert(false, \u0026quot;Don't know how to deserialise type: \u0026quot; ~ T.stringof);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere's an example of the output were we to do \u003ccode\u003edeserialise!int(JSONValue(0))\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003e.\\test.d(17): Error: static assert:  \u0026quot;Don't know how to deserialise type: int\u0026quot;\n.\\test.d(5):         instantiated from here: `deserialise!int`\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"deserialisation---cont\"\u003eDeserialisation - cont.\u003c/h3\u003e\n\u003cp\u003eCarrying on, with bools we pretty much do the same thing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003eT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /* ... */ }\n    else static if(is(T == bool)) // Please note that it is \u0026quot;else STATIC if\u0026quot;, not \u0026quot;else if\u0026quot;\n    {\n        return json.boolean;\n    }\n    else\n    { /* ... */ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor floating points while we could just check for both a float and a double in the same \u003ccode\u003estatic if\u003c/code\u003e,\nwe could instead start learning about what std.traits offers us,\nas it contains a plethora of templates that can determine certain things about a type (among other extremely useful things).\u003c/p\u003e\n\u003ch3 id=\"deserialisation---stdtraitsisfloatingpoint-and-stdconvto\"\u003eDeserialisation - std.traits#isFloatingPoint;, and std.conv#to\u003c/h3\u003e\n\u003cp\u003eSo let's start by importing std.traits at the top of the file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003eimport std.json, std.traits;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we need to add another \u003ccode\u003eelse static if\u003c/code\u003e statement into our deserialise function where we can use\nthe std.traits#isFloatingPoint template to check if \u003ccode\u003eT\u003c/code\u003e is a floating point type.\u003c/p\u003e\n\u003cp\u003eHowever, there is also one last issue we must address first. std.json#JSONValue.floating returns to us a \u003ccode\u003edouble\u003c/code\u003e,\nbut we want to support both \u003ccode\u003efloat\u003c/code\u003e and \u003ccode\u003edouble\u003c/code\u003e at the same time. While we could just cast the return value into a \u003ccode\u003efloat\u003c/code\u003e\nthis presents another issue of, what if the return value is larger than a \u003ccode\u003efloat\u003c/code\u003e can hold?\nThe cast in this case would then provide back a bad value.\u003c/p\u003e\n\u003cp\u003eSo the solution is to use another incredibly helpful function called std.conv#to;,\nwhich is a template function that can convert between different types, and provides a few sanity checks including\nthrowing an exception if we try to cast a \u003ccode\u003edouble\u003c/code\u003e to a \u003ccode\u003efloat\u003c/code\u003e where the \u003ccode\u003edouble\u003c/code\u003e is too large to fit into a \u003ccode\u003efloat\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSo get an import for std.conv going somewhere, and let's improve our deserialiser.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003e// https://run.dlang.io/is/E7c9ZP\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /* ... */ }\n    else static if(is(T == bool))\n    { /* ... */ }\n    else static if(isFloatingPoint!T)\n    {\n        return json.floating.to!T();\n    }\n    else\n    { /* ... */ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSide note that we're using a feature called \u003ca href=\"https://tour.dlang.org/tour/en/gems/uniform-function-call-syntax-ufcs\"\u003eUFCS\u003c/a\u003e\n(Uniform function call syntax) to allow us to use std.conv#to as if it were a member function for a double.\u003c/p\u003e\n\u003ch3 id=\"deserialisation---issigned-and-isunsigned\"\u003eDeserialisation - isSigned, and isUnsigned\u003c/h3\u003e\n\u003cp\u003eFinally, we're onto signed and unsigned integers.\u003c/p\u003e\n\u003cp\u003eThe std.traits module provides us with the std.traits#isSigned and std.traits#isUnsigned templates.\nThe std.traits#JSONValue.integer and the unsigned counterpart both return long/ulong,\nso we also want to use std.conv#to again for the sanity checks.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003eT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /* ... */ }\n    else static if(is(T == bool))\n    { /* ... */ }\n    else static if(isFloatingPoint!T)\n    { /* ... */ }\n    else static if(isSigned!T)\n    {\n        return json.integer.to!T();\n    }\n    else static if(isUnsigned!T)\n    {\n        return json.uinteger.to!T();\n    }\n    else\n    { /* ... */ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt's actually really simple once you understand a bit more about D's metaprogramming power, right?\u003c/p\u003e\n\u003cp\u003eAnyway, let's do a quick test to see the results of our work.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003e// https://run.dlang.io/is/unkmfu\nvoid main()\n{\n    import std.stdio;\n\n    JSONValue foo;\n\n    foo = serialise(\u0026quot;Hello world!\u0026quot;);\n    writeln(foo); // \u0026quot;Hello world!\u0026quot;\n    writeln(deserialise!string(foo)); // Hello world!\n\n    foo = 500.serialise(); // Can also use UFCS for a cleaner syntax.\n    writeln(foo); // 500\n    writeln(foo.deserialise!short()); // 500\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWe now have a serialiser that can serialise and deserialise most of D's primitive types.\nWhile it is not too useful in its current state, the next post will talk about how to start (de)serialising structs,\nwhich will turn this tiny little serialiser into something infinitely more useful.\u003c/p\u003e\n\u003ch2 id=\"excercises\"\u003eExcercises\u003c/h2\u003e\n\u003cp\u003eThere are various things I left out, either to reduce the length of this blog post,\nor to leave up to you, the reader, to implement for yourself as a challenge.\u003c/p\u003e\n\u003ch3 id=\"excercise-1---validation-checks-during-deserialisation\"\u003eExcercise #1 - Validation checks during deserialisation\u003c/h3\u003e\n\u003cp\u003eWhile std.json#JSONValue itself does checks for things like \u0026quot;take this JSONValue containing a string and convert it into a long\u0026quot;,\nadding these checks yourself can be good practice, and a great place to start getting into the habit of\nusing the std.exception#enforce function.\u003c/p\u003e\n\u003cp\u003eYou can use std.json#JSONValue.type to get the type of the std.json#JSONValue passed to the deserilise function,\nand please see std.json#JSONType to see all the different types.\u003c/p\u003e\n\u003cp\u003eHere is a test case. Just copy-paste this as your main function, and run the program.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003evoid main()\n{\n    import std.stdio     : writeln;\n    import std.exception : assertThrown, assertNotThrown;\n\n    JSONValue json = serialise(\u0026quot;Lalafell\u0026quot;);\n\n    assertThrown(json.deserialise!int());\n    assertNotThrown(json.deserialise!string());\n\n    writeln(\u0026quot;Success\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"excercise-2---allowing-conversion-between-signed-and-unsigned-integers\"\u003eExcercise #2 - Allowing conversion between signed and unsigned integers.\u003c/h3\u003e\n\u003cp\u003eBasically, you can store both signed and unsigned integers into a std.json#JSONValue;.\nBut, for example, if you store a signed integer, you can only get it back as a signed integer,\nand trying to get it back as an unsigned integer will make std.json#JSONValue throw an error.\u003c/p\u003e\n\u003cp\u003eHowever, if you got a signed integer back as a signed integer, and then converted it to an unsigned integer,\nthat'd work, although there's an argument about whether it's correct behaviour or not\n(but std.conv#to should catch most errornous conversions).\u003c/p\u003e\n\u003cp\u003eSo you must modify the deserialise function to allow \u003ccode\u003edeserialise!uint()\u003c/code\u003e to work on JSONValues\ncontaining either signed or unsigned integers, and vice versa with \u003ccode\u003edeserialise!int()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTest case:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003evoid main()\n{\n    import std.stdio     : writeln;\n    import std.exception : assertNotThrown;\n\n    JSONValue json;\n\n    // D has closures btw\n    void test()\n    {\n        assertNotThrown(json.deserialise!int());\n        assertNotThrown(json.deserialise!uint());\n        assert(json.deserialise!int() == 400);\n        assert(json.deserialise!uint() == 400);\n    }\n\n    json = serialise!uint(400u);\n    test();\n\n    json = serialise!int(400);\n    test();\n\n    writeln(\u0026quot;Success\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"excercise-3---write-test-cases-using-ds-built-in-unittesting\"\u003eExcercise #3 - Write test cases using D's built-in unittesting.\u003c/h3\u003e\n\u003cp\u003eD has built-in unittests, and this tiny project could be a good way to introduce yourself with them.\u003c/p\u003e\n\u003cp\u003eFor example, the test cases I gave for the other excercises could be moved from being in the main function, into their own unittests.\u003c/p\u003e\n","title":"Serialising basic D types","created":"0001-01-01T00:00:00Z","updated":"0001-01-01T00:00:00Z","seoUrl":"","seoTitle":"","seoDescription":""}