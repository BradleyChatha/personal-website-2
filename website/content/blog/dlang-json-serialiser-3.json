{"html":"<p><em>Side note: In true D fashion, https://run.dlang.io is broken with no sign of it being fixed (in terms of creating links),\nso from this point on I&apos;ll be using https://godbolt.org</em></p><p>In this post we&apos;ll cover how to serialise classes and enums, both of which have certain considerations to go over.</p><h2 id=\"serialising-enums\">Serialising enums</h2><p>The first thing to consider with enums is whether to serialise them via their names\n(e.g. <code>PersonType.Student</code> would become &quot;Student&quot;), or to serialise them\nvia their values.</p><p>There are pros and cons to both, mostly revolving around enums that are used as bit flags,\nbut for now we&apos;re going to serialise them by names and later on provide a way to use either\nnames or values.</p><p>We&apos;re going to need an enum to work with so let&apos;s create a <code>PersonType</code> enum\nfor our <code>Person</code> struct from our <a href=\"https://run.dlang.io/is/nCESzP\">previous code</a>:</p><pre><code>enum PersonType\n{\n    Unknown,\n    Student,\n    Staff\n}\n\nstruct Person\n{\n    string name;\n    int age;\n    PersonType type;\n}\n</code></pre><h3 id=\"the-issue-with-enums\">The issue with enums</h3><p>There is one fairly important yet easy to solve issue with enums - they count as both an enum <em>and</em> their value type.</p><p>For example, take our newly made <code>PersonType</code> enum. It is just a\nbog standard enum where the value type is an <code>int</code> (by default).</p><p>The <code>PersonType</code> enum, due to having a value type of <code>int</code>, will actually\n<strong>pass</strong> a check such as <code>is(PersonType == int)</code> and <code>isNumeric!PersonType</code>.\nNeedless to say this is a bit of a roadblock due to our decision to serialise by name instead of value.</p><p>Fortunately, this issue is actually super easy to work around. Via <code>is(T == enum)</code> we can create\ncode that works/doesn&apos;t work specifically for enums.</p><h3 id=\"upgrading-our-serialise-function\">Upgrading our serialise function</h3><p>For reference, here&apos;s the shortened code for the serialise function:</p><pre><code>enum isPrimitiveType(T) = isNumeric!T || is(T == bool) || is(T == string);\n\nJSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == struct))\n    { /* omitted for brevity */ }\n    else\n    { /* omitted for brevity */ }\n}\n</code></pre><p>There are two options for us to take here:</p><ul><li><p>Modify <code>isPrimitiveType</code> so that it ignores enums, then handle enums later on in the function.</p></li></ul><ul><li><p>Handle enums inside the function <strong>before</strong> handling primitive types, so enums have a higher &apos;priority&apos;.</p></li></ul><p>We will in fact be doing both: option #1 for the <code>serialise</code> function, and then option #2 for the</p><p><code>deserialise</code> function. This is to demonstrate both options.</p><p>To start, we can use <code>!is(T == enum)</code> with <code>isPrimitiveType</code> so that it will ignore enums:</p><pre><code>// https://godbolt.org/z/_edV5X\nenum isPrimitiveType(T) = !is(T == enum) && (isNumeric!T || is(T == bool) || is(T == string));    \n</code></pre><p>Next we need to add a <code>static if</code> so we can handle enums, and then turn the enum\nvalue into its name with the help of the ever-so-useful std.conv#to function:</p><pre><code>JSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    {\n        return JSONValue(value.to!string()); // PersonType.Student -> \"Student\", PersonType.Staff -> \"Staff\", etc.\n    }\n    else static if(is(T == struct))\n    { /* omitted for brevity */ }\n    else\n    { /* omitted for brevity */ }\n}    \n</code></pre><p>Note that if you do something weird such as <code>cast(PersonType)400</code>, then</p><p><code>std.conv.to</code> will actually return <code>\"cast(PersonType)400\"</code>, which\nwill cause errors down the line.</p><h3 id=\"upgrading-our-deserialise-function\">Upgrading our deserialise function</h3><p>For reference, here&apos;s the shortened code for the deserialise function:</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /* omitted for brevity */ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }   \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct))\n    { /**/ }\n    else\n    { /**/ }\n}\n</code></pre><p>As I mentioned before, the <code>deserialise</code> function is going to handle\nenums before any other type, so that the enum path takes priority over the others.</p><p>Yet again, our lord and savior std.conv#to comes to our rescue as it can convert a string into an enum\nas long as the string has the same name as one of the enum values:</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    {\n        // \"Student\" -> PersonType.Student, etc.\n        return json.str.to!T();\n    }\n    else static if(is(T == string))\n    { /* omitted for brevity */ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }   \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct))\n    { /**/ }\n    else\n    { /**/ }\n}     \n</code></pre><p>Finally, as usual, we&apos;ll give things a quick test:</p><pre><code>// https://godbolt.org/z/f4xTyB\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto json = serialise(PersonType.Student);\n    writeln(json);\n    writeln(json.deserialise!PersonType());\n\n    json = serialise(Person(\"Bradley\", 20, PersonType.Student));\n    writeln(json);\n    writeln(json.deserialise!Person());\n\n    /*\n        Output:\n            \"Student\"\n            Student\n            {\"age\":20,\"name\":\"Bradley\",\"type\":\"Student\"}\n            Person(\"Bradley\", 20, Student)\n    */\n}\n</code></pre><h2 id=\"serialising-classes\">Serialising classes</h2><p>Serialising classes is where a lot of the more important decisions come into play, because\nstructs and classes are very different from one another.</p><p>For example, while we <em>could</em> just treat classes like they&apos;re structs, that will only support\na very tiny amount of classes because:</p><ul><li><p>Classes can be null.</p></li></ul><ul><li><p>Classes may not have a reliable way to construct them (more on that later in the post).</p></li></ul><ul><li><p>Classes tend to not expose variables directly, but via getters, setters, and other functions.</p></li></ul><ul><li><p>And many other reasons...</p></li></ul><p>This post will provide a way to handle some of these issues, but in a real project you may\nneed to fine tune how the serialiser works for your own needs as my solutions are going to be\nrelatively basic and therefore, not as robust as they could be.</p><h3 id=\"treating-classes-as-structs\">Treating classes as structs</h3><p>Before we can start taking on some of the other issues we need to treat the most\nbasic case of simply being able to serialise and deserialise a class&apos; public variables,\nand then build off of that.</p><p>For now we&apos;ll assume that all classes passed to the serialise function are not-null.\nSo for serialisation we can very simply just modify the <code>static if</code> that checks\nfor a struct, and extend it to also check for a class:</p><pre><code>JSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class)) // <-----\n    { /**/ }\n    else\n    { /**/ }\n}   \n</code></pre><p>This will work for extremely simple classes, e.g. if you were to change <code>Person</code>\nto a class it should be able to serialise a non-null instance of it perfectly fine.</p><p>For the deserialise function our biggest hurdle is constructing a new instance of the class\nso we can populate its fields. For now, our code will just assume that there is a default constructor\n(e.g. <code>new MyClass()</code> works). Also keep in mind that <code>static if</code> does not create a scope:</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class)) // Remember to check for a class here as well.\n    {\n        static if(is(T == class))\n        {\n            T toReturn = new T();\n        }\n        else\n        {\n            T toReturn; // Classes default to `null`, so we can't just reuse this line with them.\n        }\n\n        static foreach(member; T.tupleof)\n        {{\n            /**/\n        }}\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>As a quick example, change/copy <code>Person</code> to a class, and then we can\ntest if it works:</p><pre><code>// https://godbolt.org/z/EhHVdN\nvoid main()\n{\n    import std.stdio : writeln, writefln;\n\n    // The compiler doesn't generate a helper constructor like with structs,\n    // so we'll do things like this for now.\n    auto p = new Person();\n    p.name = \"Bradley\";\n    p.age = 20;\n    p.type = PersonType.Student;\n\n    auto json = p.serialise();\n    writeln(json);\n\n    // writeln can't automatically format a class like with structs.\n    // So either override the `toString` function in a class, or just manually write out the fields.\n    writefln(\"Person(%s, %s, %s)\", p.name, p.age, p.type);\n\n    /*\n        Output:\n            {\"age\":20,\"name\":\"Bradley\",\"type\":\"Student\"}\n            Person(Bradley, 20, Student)\n    */\n}\n</code></pre><h3 id=\"handling--classes-can-be-null-\">Handling &apos;classes can be null&apos;</h3><p>Realistically, being able to handle null classes is a mandatory requirement, so\nlet&apos;s get that out of the way quickly.</p><p>For serialising we can check if the class is null, and if it is then we can return a <code>JSONValue(null)</code>:</p><pre><code>JSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    {\n        JSONValue toReturn;\n\n        static if(is(T == class))\n        {\n            if(value is null)\n            {\n                return JSONValue(null);\n            }\n        }\n\n        static foreach(member; T.tupleof)\n        {{\n            /**/\n        }}\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>Now if we were to pass a null class instance to the <code>serialise</code> function\nit would output a <code>null</code> in JSON.</p><p>For our <code>deserialise</code> function it&apos;s a very similar process - check if\nthe given JSON value is null, and if it is then return null:</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class)) // Remember to check for a class here as well.\n    {\n        static if(is(T == class))\n        {\n            if(json.type == JSONType.null_)\n                return null;\n\n            T toReturn = new T();\n        }\n        else\n        {\n            T toReturn;\n        }\n\n        /**/\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>Very simple and very easy to handle, unlike the can of worms we&apos;re about to open regarding\nconstruction of a class.</p><p>But before we fall into despair over constructing classes, here&apos;s a quick test of the null\nhandling (change <code>Person</code> to a class):</p><pre><code>// https://godbolt.org/z/Q8pU7v\nvoid main()\n{\n    import std.stdio : writeln;\n\n    Person p = null;\n    auto json = p.serialise();\n\n    writeln(json);\n    writeln(json.deserialise!Person());\n\n    /*\n        Output:\n            null\n            null\n    */\n}\n</code></pre><h3 id=\"handling--classes-may-not-have-a-reliable-way-to-construct-them--with---traits-compiles-\">Handling &apos;classes may not have a reliable way to construct them&apos; with __traits(compiles)</h3><p>Currently, we use the code <code>new T()</code> to construct a new instance of a class.\nThis will only work if the class has either no constructors, or a default constructor.</p><p>Again, realistically, classes are very likely to have parameterised constructors and are likely\nincapable of supporting a default constructor.</p><p>Just as a note, this only applies to deserialisation as serialising does not require\nthe construction of objects (well, unless you want it to).</p><p>There are many ways you may want to handle this, such as using std.traits#Parameters\nto check and recognise constructors with certain parameter patterns, having\na pre-defined list of constructor parameters that you support, or just\nnot allowing classes that do not contain a default constructor.</p><p>In our case we&apos;re going to disallow the use of classes that do not contain a default\nconstructor. Fret not though, as we will be exploring one potential workaround soon.</p><p>But for now we&apos;re going to be creating ourselves a helper template called <code>HasDefaultCtor</code>,\nand we&apos;ll use that in our <code>deserialise</code> function to check if it returns <code>false</code>.</p><p>One way we can do this is to check if the exact code of <code>new T()</code> can compile,\nwhich we can achieve via another magical form of <code>__traits()</code> called\n<a href=\"https://dlang.org/spec/traits.html#compiles\">__traits(compiles)</a>.</p><p>By passing in some code as a parameter the compiler will determine if the code will\ncompile or not, and return a <code>bool</code> as the result.</p><p>Please note that there is a certain annoyance to <code>__traits(compiles)</code> when the code\nyou&apos;re checking contains a template function, but such quirk is beyond this quick explanation of it.</p><p>Anyway, by telling the compiler to check if <code>new T()</code> works for a given type\nwe can effectively check if the type has a default constructor, and then from there\nwe can use a <code>static assert</code> to display a message to the user:</p><pre><code>enum HasDefaultCtor(T) = __traits(compiles, new T());\n\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        static if(is(T == class))\n        {\n            static assert(HasDefaultCtor!T, \"The class `\" ~ T.stringof ~ \"` requires a default constructor.\");\n\n            /**/\n        }\n        else\n        {\n        /\t**/\n        }\n\n        /**/\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>Here is an example of the error message:</p><pre><code>// https://godbolt.org/z/NSwveB\n\nclass NoDefaultCtor\n{\n    this(string str){}\n}\n\nvoid main()\n{\n    deserialise!NoDefaultCtor(JSONValue());\n\n    /*\n        Output:\n            .\\temp.d(27): Error: static assert:  \"The class `NoDefaultCtor` requires a default constructor.\"\n            .\\temp.d(10):        instantiated from here: `deserialise!(NoDefaultCtor)`\n    */\n}\n</code></pre><p>This isn&apos;t overly ideal for many reasons but thankfully as we explore the workaround\nwe&apos;ll implement something that handles this issue to a somewhat reasonable degree.</p><h3 id=\"workaround-for-the-constructor-issue--and-the-fact-classes-tend-to-not-expose-variables-directly\">Workaround for the constructor issue, and the fact classes tend to not expose variables directly</h3><p>I&apos;ll be brief. I&apos;ve already gone over the constructor issue; and\nbecause classes usually don&apos;t expose variables directly our current behaviour won&apos;t work for most\nof them.</p><p>Regarding the latter issue, there are several ways to handle the issue ranging from directly\ninspecting the names of functions for keywords (e.g. starting with &quot;get&quot; or &quot;set&quot;), looking for\ngetters/setters that use the <code>@property</code> attribute, and any other ways suitable\nfor your use cases.</p><p>The solution I will be going for is to add support for classes and structs to provide a static</p><p><code>deserialise</code> function. This will serve as a workaround for the constructor issue as this\nis essentially just a special constructor, and will also outsource the task of handling deserialisation\nto the class itself, which <em>technically</em> handles the issue of classes not generally exposing variables.</p><p>A downside of course is that there&apos;s more code to be written for classes to support\ndeserialisation, and therefore more technical debt over the long term.</p><p>While you could also just specifically check for a constructor that takes a <code>JSONValue</code>,\nI prefer to create specific functions for things like this as I don&apos;t like\nthat it&apos;ll limit classes from providing a <code>this(JSONValue)</code> constructor for other\npurposes.</p><p>The first thing we&apos;ll do is create another helper template (similar to <code>HasDefaultCtor</code>)\nthat will check for the special <code>deserialise</code> function.</p><p>This template needs to check for:</p><ul><li><p>A static function called <code>deserialise</code>.</p></li></ul><ul><li><p>The function&apos;s return value is the same/compatible type as the class.</p></li></ul><ul><li><p>The function takes a <code>JSONValue</code> as the first parameter.</p></li></ul><p>There are a few ways to do this, however we&apos;ll be using the trusty <code>__traits(compiles)</code> again:</p><pre><code>enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    \n</code></pre><p>Notice that the code we&apos;re checking is now inside brackets, since we&apos;re doing more\nthan a basic function call.</p><p>We&apos;re using <code>T.deserialise</code> to specifically check for a static function\n(or anything that has the same syntax as a static function); we assign the return value\nto a <code>T obj</code> to check that the return value is compatible with whatever <code>T</code> is;\nthen finally we also check that a <code>JSONValue</code> can be passed as the first parameter.</p><p>Next, in the <code>deserialise</code> function, we want to update the <code>static assert</code>\nthat requires classes to have a default constructor to check if the class has either\na default constructor, or a static deserialise function.</p><p>We also need to hide the <code>T toReturn = new T()</code> line behind\nthe <code>HasDefaultCtor</code> check:</p><pre><code>enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    \n\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        static if(is(T == class))\n        {\n            static assert(HasDefaultCtor!T || HasStaticDeserialiseFunc!T, \n                \"The class `\" ~ T.stringof ~ \"` requires a default constructor or a function matching \"\n                ~\"`static \" ~ T.stringof ~ \" deserialise(JSONValue)`\"\n            ); \n            // e.g. \"The class Person requires a default constructor or a function matching `static Person deserialise(JSONValue)`\"\n\n            /**/\n\n            static if(HasDefaultCtor!T)\n            {\n                T toReturn = new T();\n            }\n        }\n        /**/\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>Now, if the class has a static deserialise function then we want to use that function\nfor deserialisation instead of our other logic. We still want to handle null std.json#JSONValue:JSONValues,\nand we want to disable our other logic as we won&apos;t need it due to another issue of having\ncode exist beyond a <code>return</code> statement.</p><p>To do this we just need to tactically employ <code>static if</code>:</p><pre><code>enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    \n\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        static if(is(T == class))\n        { /* null is still handled here */ }\n        else\n        { /**/ }\n\n        static if(HasStaticDeserialiseFunc!T)\n        {\n            return T.deserialise(json);\n        }\n        else // If we don't disable this other code, then we'll get a \"statement not reachable\" error.\n        {\n            static foreach(/**/)\n            {{\n                /**/\n            }}\n            return toReturn;\n        }\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>To finish off, let&apos;s give it a test:</p><pre><code>// https://godbolt.org/z/Xbann8\n\nclass Person\n{\n    private\n    {\n        string name;\n        int age;\n        PersonType type;\n    }\n\n    // No default ctor.\n    this(string name, int age, PersonType type)\n    {\n        this.name = name;\n        this.age = age;\n        this.type = type;\n    }\n\n    static Person deserialise(JSONValue value)\n    {\n        // Classes having to implement this logic themselves is a neccessary burden if you\n        // were to go this route... or is it *wink* (this is a topic for a future post)\n        return new Person(\n            value[\"name\"].deserialise!string(),\n            value[\"age\"].deserialise!int(),\n            value[\"type\"].deserialise!PersonType()\n        );\n    }\n\n    // So that writeln can show us something useful.\n    override string toString()\n    {\n        import std.format : format;\n\n        return format(\"Person(%s, %s, %s)\", this.name, this.age, this.type);\n    }\n}\n\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person = new Person(\"Bradley\", 20, PersonType.Student);\n    auto json = person.serialise();\n\n    writeln(json);\n\n    person = json.deserialise!Person();\n    writeln(person);\n\n    /*\n        Output:\n            {\"age\":20,\"name\":\"Bradley\",\"type\":\"Student\"}\n            Person(Bradley, 20, Student)\n    */\n}\n</code></pre><h2 id=\"conclusion\">Conclusion</h2><p>Our serialiser can now serialise enums by name and has some dodgey support for serialising\nclasses, meaning it&apos;s starting to shape up to be at least <em>kind of</em> useable. Maybe.\nIf you&apos;re desperate.</p><p>The next thing we&apos;ll look into is to serialise arrays and associative arrays.</p><h2 id=\"excercises\">Excercises</h2><h3 id=\"add-support-for-classes-and-structs-to-provide-their-own-serialise-function\">Add support for classes and structs to provide their own serialise function</h3><p>This might be something I end up doing in a future post, but for now this is a\ngood excercise to practice using <code>__traits(compiles)</code>.</p><p>Basically, allow classes and structs to provide a custom <code>serialise</code> function.</p><p>For the test case to work, the serialise function must match the signature of: <code>JSONValue serialise()</code></p><p>And here&apos;s the test case:</p><pre><code>struct VerySimpleTest\n{\n    string lalafell;\n\n    JSONValue serialise()\n    {\n        JSONValue json;\n\n        json[\"lalafell\"] = this.lalafell;\n        json[\"hidden_secret\"] = \"Don't be a lalafell please.\";\n\n        return json;\n    }\n}\n\nvoid main()\n{\n    auto json = serialise(VerySimpleTest(\"Zuzu\"));\n    assert(json[\"lalafell\"].str == \"Zuzu\");\n    assert(json[\"hidden_secret\"].str == \"Don't be a lalafell please.\");\n}\n</code></pre>","metadata":["dlang-json-serialiser-3","serialise-enum-class","31-10-2019","Serialising enums and classes","07-02-2020"],"headers":[{"text":"Serialising enums","slug":"serialising-enums","level":2},{"text":"The issue with enums","slug":"the-issue-with-enums","level":3},{"text":"Upgrading our serialise function","slug":"upgrading-our-serialise-function","level":3},{"text":"Upgrading our deserialise function","slug":"upgrading-our-deserialise-function","level":3},{"text":"Serialising classes","slug":"serialising-classes","level":2},{"text":"Treating classes as structs","slug":"treating-classes-as-structs","level":3},{"text":"Handling 'classes can be null'","slug":"handling--classes-can-be-null-","level":3},{"text":"Handling 'classes may not have a reliable way to construct them' with __traits(compiles)","slug":"handling--classes-may-not-have-a-reliable-way-to-construct-them--with---traits-compiles-","level":3},{"text":"Workaround for the constructor issue, and the fact classes tend to not expose variables directly","slug":"workaround-for-the-constructor-issue--and-the-fact-classes-tend-to-not-expose-variables-directly","level":3},{"text":"Conclusion","slug":"conclusion","level":2},{"text":"Excercises","slug":"excercises","level":2},{"text":"Add support for classes and structs to provide their own serialise function","slug":"add-support-for-classes-and-structs-to-provide-their-own-serialise-function","level":3}]}