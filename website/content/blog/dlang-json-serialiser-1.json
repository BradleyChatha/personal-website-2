{"html":"<p>Have you ever wondered about how serialisers (or other pieces of code) perform their &apos;magic&apos;? Are you someone\nwho wants to learn how to perform such seemingly arcane feats yourself? Or are you simply someone who wants to learn more about D?</p><p>Regardless of your reason for being here, with the power of D I&apos;ll be taking you through the steps of creating a basic\nJSON Serialiser that uses compile-time introspection/reflection to serialise any random object!</p><p>To achieve this, we&apos;ll be using one of D&apos;s most powerful features: <a href=\"https://tour.dlang.org/tour/en/gems/template-meta-programming\">metaprogramming</a></p><p>This series is aimed towards people who are new/interested in D, while its purpose is to teach and \nshow off different aspects of D&apos;s metaprogramming features, ending with the creation of a semi-useful serialiser/deserialiser for JSON.</p><p>This first post will cover the creation of two template functions, which, as the series progresses, will \nbegin to use a broad range of D&apos;s meta programming features to determine how to serialise/deserialise most of D&apos;s primitive types.</p><p>Some code snippets may start with a comment containing a link to https://run.dlang.io/\nwhich will take you to an online D environment containing a runnable version of that snippet.</p><h2 id=\"requirements\">Requirements</h2><ul><li><p>The ability to write and compile D code</p></li></ul><ul><li><p>A basic understanding of what a template is (in any language)</p></li></ul><ul><li><p>A ~~rubber ducky~~ <a href=\"https://dlang.org/images/dman-rain.jpg\">D man</a> close by.</p></li></ul><h2 id=\"std-json\">std.json</h2><p>To make these examples as frictionless to compile as possible, the code will only use\n<a href=\"https://dlang.org/phobos/\">Phobos</a>, D&apos;s standard library, which luckily for us\nincludes a (rather outdated) JSON module called std.json</p><h2 id=\"what-are-the-primitive-types-\">What are the primitive types?</h2><p>For the context of this blog series, a primitive type is type built into the language itself.</p><ul><li><p>Integers: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, including their unsigned versions (ubyte, ushort, etc.)</p></li></ul><ul><li><p>Floating point: <code>float</code>, <code>double</code>, and <code>real</code> (which we won&apos;t bother with)</p></li></ul><ul><li><p>Booleans: <code>true</code> or <code>false</code>.</p></li></ul><ul><li><p>Strings</p></li></ul><ul><li><p>There are also chars, but in D they&apos;re UTF8 code units which are a bit weird to handle, so I&apos;m just going to ignore them.</p></li></ul><h2 id=\"serialising-primitive-types\">Serialising primitive types</h2><p>To start off let&apos;s begin with a simple D file that contains an empty main function, and imports std.json;:</p><pre><code>import std.json;\n\nvoid main()\n{\n}\n</code></pre><p>Next we want to create a basic template function called <code>serialise</code>. \nThis function will take a template parameter of any type (<code>T</code>), \nand returns a std.json#JSONValue which is the main struct that std.json uses to represent JSON values.</p><p>One of the interesting things about std.json#JSONValue is that its constructor is also a template, \nwhich conveniently supports being able to automatically wrap around any primitive type (and more) that D has.</p><p>This means that to serialise a primitive type all we must do is construct a std.json#JSONValue\nand pass our primitive value directly to it. \nDon&apos;t think things are this convenient later down the road though.</p><pre><code>JSONValue serialise(T)(T value)\n{\n    return JSONValue(value);\n}\n</code></pre><p>And it can be used like so:</p><pre><code>// run.dlang.io/is/0pBFdu\nvoid main()\n{\n    import std.stdio : writeln;\n\n    JSONValue json;\n\n    // Here we use `!int` to directly specify that `T` is of type `int`.\n    json = serialise!int(420);\n    writeln(json); // 420\n\n    // However, the compiler can actually infer what `T` is based off of the parameters we pass through.\n    // So here, `T` would be `string`.\n    json = serialise(\"Hello world!\");\n    writeln(json); // \"Hello world!\", including the quotes.\n}\n</code></pre><p>Simple enough, however right now we&apos;re letting the user pass through any type they want into our <code>serialise</code> function, \nbut we would like to distinguish between primitive types and any other future types we may want to handle such as structs, \nclasses, and enums, all of which are unable to be serialised directly by std.json#JSONValue:JSONValue&apos;s constructor.</p><p>&quot;How do we do this?&quot; you may ask. The answer is <code>static if</code>.</p><h2 id=\"static-if\">Static if</h2><p>If you&apos;re familiar with C++&apos;s <code>#if</code> directive\nthen <code>static if</code> should make you feel right at home (without all the downsides of <code>#if</code>).</p><p><code>static if</code> is like a normal <code>if</code> statement, except: </p><ul><li><p>It only runs at compile time, so its condition must also be able to be evaluated at compile time.</p></li></ul><ul><li><p>It doesn&apos;t create a new scope.</p></li></ul><ul><li><p>Any code that isn&apos;t inside a <code>static if</code>&apos;s passing block (either the <code>if</code> or the <code>else</code>) will be ignored by the compiler (outside of syntax checks).</p></li></ul><p>For example, say I wanted to have a compile time flag in my code that determined whether my program performs logging, </p><p><code>static if</code> could be used in this situation:</p><pre><code>// https://run.dlang.io/is/yjxGYT\nconst bool SHOULD_LOG = true; // This value is readable at compile time, so can be used in static if.\n\nvoid main()\n{\n    import std.stdio : writeln;\n\n    static if(SHOULD_LOG)\n    {\n        writeln(\"This is a log!\");\n    }\n\n    writeln(\"Done Task.\");\n}\n</code></pre><p>If <code>SHOULD_LOG</code> is true then the line <code>writeln(\"This is a log!\")</code> is compiled into the program, otherwise\neverything inside of the <code>static if</code> is ignored by the compiler. </p><h2 id=\"deserialising-primitive-types\">Deserialising primitive types</h2><p>Now that we know how <code>static if</code> works we can move onto deserialising primitive types, \nas it&apos;s less straight forward than serialising them.</p><p>To start, we&apos;ll make a deserialise function that takes a std.json#JSONValue, a type parameter (<code>T</code>), and returns a <code>T</code>.</p><pre><code>// The `T` can be passed by doing `deserialise!int(someJsonValue)`, where `T` would then be `int`.\nT deserialise(T)(JSONValue json)\n{\n    assert(false, \"Not implemented\");\n}\n</code></pre><p>Now, converting a std.json#JSONValue back into primitive values isn&apos;t as convenient as the other way around \n(edit: this was written before std.json#JSONValue.get was added).</p><p>Instead, std.json#JSONValue has specific functions for converting back into different types:</p><ul><li><p>std.json#JSONValue.str - Convert to a string\nstd.json#JSONValue.integer - Convert to a long\nstd.json#JSONValue.uinteger - Convert to a ulong\nstd.json#JSONValue.floating - Convert to a double\nstd.json#JSONValue.boolean - Convert to a bool</p></li></ul><p>This means we have to use static if to determine which of the correct functions to call. \nIt should be noted that if for example, you tried to convert a std.json#JSONValue containing a string into a long then an error would be thrown, \nmaking it mandatory that the right function is called.</p><h3 id=\"deserialisation---is---expression\">Deserialisation - is() expression</h3><p>Let&apos;s start off with strings. There is an expression in D called the <code>is()</code> expression, which has some very magical features \nbut the most basic one is to compare one type to another.</p><p>I feel this is best shown by example, so let&apos;s use <code>static if</code> and <code>is()</code> together to determine if our type parameter (<code>T</code>) is a string, \nand then call std.json#JSONValue.str;.</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    // Yea, it's actually that easy.\n    static if(is(T == string))\n    {\n        return json.str;\n    }\n}\n</code></pre><p>One particular issue we have though is that with our current code things like <code>deserialise!string(JSONValue(\"Hello world!\"))</code> would work, \nhowever if we were to do something such as <code>deserialise!int</code>, which we currently don&apos;t have code to handle, we&apos;d get a compiler error \ncomplaining that there&apos;s no return value (since the static if doesn&apos;t compile a return statement in that case).</p><p>What if we could create our own error messages for a more user friendly experience? In comes <code>static assert</code>.</p><h3 id=\"deserialisation---static-assert\">Deserialisation - static assert</h3><p><code>static assert</code> is a compile time version of <code>assert</code> (requires a condition that must be true otherwise crash the program), \nthat instead of crashing the program if its condition fails it will instead fail compliation, \noptionally displaying a user-defined message.</p><p>In the event that all of our <code>static if</code>s fail to have their conditions met, we can then fall back to a </p><p><code>static assert</code> that prints a user friendly message.</p><p>We can use the special <code>.stringof</code> property every type has to get a human readable string of whatever type <code>T</code> currently is.</p><pre><code>// https://run.dlang.io/is/nd2LYl\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    {\n        return json.str;\n    }\n    else\n    {\n        static assert(false, \"Don't know how to deserialise type: \" ~ T.stringof);\n    }\n}\n</code></pre><p>Here&apos;s an example of the output were we to do <code>deserialise!int(JSONValue(0))</code>:</p><pre><code>.\\test.d(17): Error: static assert:  \"Don't know how to deserialise type: int\"\n.\\test.d(5):         instantiated from here: `deserialise!int`\n</code></pre><h3 id=\"deserialisation---cont-\">Deserialisation - cont.</h3><p>Carrying on, with bools we pretty much do the same thing: </p><pre><code>T deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /* ... */ }\n    else static if(is(T == bool)) // Please note that it is \"else STATIC if\", not \"else if\"\n    {\n        return json.boolean;\n    }\n    else\n    { /* ... */ }\n}\n</code></pre><p>For floating points while we could just check for both a float and a double in the same <code>static if</code>, \nwe could instead start learning about what std.traits offers us, \nas it contains a plethora of templates that can determine certain things about a type (among other extremely useful things).</p><h3 id=\"deserialisation---std-traits-isfloatingpoint---and-std-conv-to\">Deserialisation - std.traits#isFloatingPoint;, and std.conv#to</h3><p>So let&apos;s start by importing std.traits at the top of the file: </p><pre><code>import std.json, std.traits;\n</code></pre><p>Now we need to add another <code>else static if</code> statement into our deserialise function where we can use\nthe std.traits#isFloatingPoint template to check if <code>T</code> is a floating point type.</p><p>However, there is also one last issue we must address first. std.json#JSONValue.floating returns to us a <code>double</code>, \nbut we want to support both <code>float</code> and <code>double</code> at the same time. While we could just cast the return value into a <code>float</code> \nthis presents another issue of, what if the return value is larger than a <code>float</code> can hold? \nThe cast in this case would then provide back a bad value.</p><p>So the solution is to use another incredibly helpful function called std.conv#to;, \nwhich is a template function that can convert between different types, and provides a few sanity checks including \nthrowing an exception if we try to cast a <code>double</code> to a <code>float</code> where the <code>double</code> is too large to fit into a <code>float</code>.</p><p>So get an import for std.conv going somewhere, and let&apos;s improve our deserialiser.</p><pre><code>// https://run.dlang.io/is/E7c9ZP\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /* ... */ }\n    else static if(is(T == bool))\n    { /* ... */ }\n    else static if(isFloatingPoint!T)\n    {\n        return json.floating.to!T();\n    }\n    else\n    { /* ... */ }\n}\n</code></pre><p>Side note that we&apos;re using a feature called <a href=\"https://tour.dlang.org/tour/en/gems/uniform-function-call-syntax-ufcs\">UFCS</a> \n(Uniform function call syntax) to allow us to use std.conv#to as if it were a member function for a double.</p><h3 id=\"deserialisation---issigned--and-isunsigned\">Deserialisation - isSigned, and isUnsigned</h3><p>Finally, we&apos;re onto signed and unsigned integers.</p><p>The std.traits module provides us with the std.traits#isSigned and std.traits#isUnsigned templates. \nThe std.traits#JSONValue.integer and the unsigned counterpart both return long/ulong, \nso we also want to use std.conv#to again for the sanity checks.</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /* ... */ }\n    else static if(is(T == bool))\n    { /* ... */ }\n    else static if(isFloatingPoint!T)\n    { /* ... */ }\n    else static if(isSigned!T)\n    {\n        return json.integer.to!T();\n    }\n    else static if(isUnsigned!T)\n    {\n        return json.uinteger.to!T();\n    }\n    else\n    { /* ... */ }\n}\n</code></pre><p>It&apos;s actually really simple once you understand a bit more about D&apos;s metaprogramming power, right?</p><p>Anyway, let&apos;s do a quick test to see the results of our work.</p><pre><code>// https://run.dlang.io/is/unkmfu\nvoid main()\n{\n    import std.stdio;\n\n    JSONValue foo;\n\n    foo = serialise(\"Hello world!\");\n    writeln(foo); // \"Hello world!\"\n    writeln(deserialise!string(foo)); // Hello world!\n\n    foo = 500.serialise(); // Can also use UFCS for a cleaner syntax.\n    writeln(foo); // 500\n    writeln(foo.deserialise!short()); // 500\n}\n</code></pre><h2 id=\"conclusion\">Conclusion</h2><p>We now have a serialiser that can serialise and deserialise most of D&apos;s primitive types. \nWhile it is not too useful in its current state, the next post will talk about how to start (de)serialising structs, \nwhich will turn this tiny little serialiser into something infinitely more useful. </p><h2 id=\"excercises\">Excercises</h2><p>There are various things I left out, either to reduce the length of this blog post, \nor to leave up to you, the reader, to implement for yourself as a challenge.</p><h3 id=\"excercise--1---validation-checks-during-deserialisation\">Excercise #1 - Validation checks during deserialisation</h3><p>While std.json#JSONValue itself does checks for things like &quot;take this JSONValue containing a string and convert it into a long&quot;, \nadding these checks yourself can be good practice, and a great place to start getting into the habit of \nusing the std.exception#enforce function.</p><p>You can use std.json#JSONValue.type to get the type of the std.json#JSONValue passed to the deserilise function, \nand please see std.json#JSONType to see all the different types.</p><p>Here is a test case. Just copy-paste this as your main function, and run the program.</p><pre><code>void main()\n{\n    import std.stdio     : writeln;\n    import std.exception : assertThrown, assertNotThrown;\n\n    JSONValue json = serialise(\"Lalafell\");\n\n    assertThrown(json.deserialise!int());\n    assertNotThrown(json.deserialise!string());\n\n    writeln(\"Success\");\n}\n</code></pre><h3 id=\"excercise--2---allowing-conversion-between-signed-and-unsigned-integers-\">Excercise #2 - Allowing conversion between signed and unsigned integers.</h3><p>Basically, you can store both signed and unsigned integers into a std.json#JSONValue;. \nBut, for example, if you store a signed integer, you can only get it back as a signed integer, \nand trying to get it back as an unsigned integer will make std.json#JSONValue throw an error.</p><p>However, if you got a signed integer back as a signed integer, and then converted it to an unsigned integer, \nthat&apos;d work, although there&apos;s an argument about whether it&apos;s correct behaviour or not \n(but std.conv#to should catch most errornous conversions).</p><p>So you must modify the deserialise function to allow <code>deserialise!uint()</code> to work on JSONValues \ncontaining either signed or unsigned integers, and vice versa with <code>deserialise!int()</code>.</p><p>Test case:</p><pre><code>void main()\n{\n    import std.stdio     : writeln;\n    import std.exception : assertNotThrown;\n\n    JSONValue json;\n\n    // D has closures btw\n    void test()\n    {\n        assertNotThrown(json.deserialise!int());\n        assertNotThrown(json.deserialise!uint());\n        assert(json.deserialise!int() == 400);\n        assert(json.deserialise!uint() == 400);\n    }\n\n    json = serialise!uint(400u);\n    test();\n\n    json = serialise!int(400);\n    test();\n\n    writeln(\"Success\");\n}\n</code></pre><h3 id=\"excercise--3---write-test-cases-using-d-s-built-in-unittesting-\">Excercise #3 - Write test cases using D&apos;s built-in unittesting.</h3><p>D has built-in unittests, and this tiny project could be a good way to introduce yourself with them.</p><p>For example, the test cases I gave for the other excercises could be moved from being in the main function, into their own unittests.</p>","metadata":["dlang-json-serialiser-1","serialise-basic-d-types","31-10-2019","Serialising basic D types","06-02-2020"],"headers":[{"text":"Requirements","slug":"requirements","level":2},{"text":"std.json","slug":"std-json","level":2},{"text":"What are the primitive types?","slug":"what-are-the-primitive-types-","level":2},{"text":"Serialising primitive types","slug":"serialising-primitive-types","level":2},{"text":"Static if","slug":"static-if","level":2},{"text":"Deserialising primitive types","slug":"deserialising-primitive-types","level":2},{"text":"Deserialisation - is() expression","slug":"deserialisation---is---expression","level":3},{"text":"Deserialisation - static assert","slug":"deserialisation---static-assert","level":3},{"text":"Deserialisation - cont.","slug":"deserialisation---cont-","level":3},{"text":"Deserialisation - std.traits#isFloatingPoint;, and std.conv#to","slug":"deserialisation---std-traits-isfloatingpoint---and-std-conv-to","level":3},{"text":"Deserialisation - isSigned, and isUnsigned","slug":"deserialisation---issigned--and-isunsigned","level":3},{"text":"Conclusion","slug":"conclusion","level":2},{"text":"Excercises","slug":"excercises","level":2},{"text":"Excercise #1 - Validation checks during deserialisation","slug":"excercise--1---validation-checks-during-deserialisation","level":3},{"text":"Excercise #2 - Allowing conversion between signed and unsigned integers.","slug":"excercise--2---allowing-conversion-between-signed-and-unsigned-integers-","level":3},{"text":"Excercise #3 - Write test cases using D's built-in unittesting.","slug":"excercise--3---write-test-cases-using-d-s-built-in-unittesting-","level":3}]}