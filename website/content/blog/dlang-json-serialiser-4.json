{"uid":"dlang-json-serialiser-4","html":"\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote that in the previous post, the \u003ccode\u003ePerson\u003c/code\u003e struct was converted into a class\u003c/em\u003e\n\u003cem\u003efor testing purposes. From this point on \u003ccode\u003ePerson\u003c/code\u003e is a struct again unless specified otherwise.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eOne of the final things missing before our serialiser can reach a \u0026quot;minimalistic but useable\u0026quot; state\nis the ability to serialise both dynamic and associative arrays. Static arrays are saved as an excercise\nfor this post.\u003c/p\u003e\n\u003cp\u003eI've already covered the majority of the main metaprogramming features that'll be used in this post, and arrays\nare relatively simple to serialise, so this post will be on the shorter end.\u003c/p\u003e\n\u003ch2 id=\"serialising-dynamic-arrays\"\u003eSerialising dynamic arrays\u003c/h2\u003e\n\u003cp\u003eAs usual, here's our current serialise function for reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else\n    { /**/ }\n}    \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor dynamic arrays we need to iterate over the array's elements; serialise\nthem, and then append the serialised value into a JSON array.\u003c/p\u003e\n\u003cp\u003eThere's not too much to explain about to code, so I'll quickly highlight two things:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eWe use std.traits#isDynamicArray to check if \u003ccode\u003eT\u003c/code\u003e is a dynamic array.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCreating a std.json#JSONValue that is also an array is a bit iffy, using \u003ccode\u003eparseJSON(\u0026quot;[]\u0026quot;)\u003c/code\u003e was the cleanest way I could find.\n(std.json is pretty outdated)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else static if(isDynamicArray!T)\n    {\n        JSONValue toReturn = parseJSON(\u0026quot;[]\u0026quot;);\n        \n        foreach(element; value)\n        {\n            toReturn.array ~= serialise(element);\n        }\n        \n        return toReturn;\n    }\n    else\n    { /**/ }\n} \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDo note that \u003ccode\u003estring\u003c/code\u003e in D is actually just an \u003ccode\u003eimmutable(char)[]\u003c/code\u003e, which\nwould satisfy the std.json#isDynamicArray template.\u003c/p\u003e\n\u003cp\u003eThis isn't so much an issue in our case due to the fact we handle \u003ccode\u003estring\u003c/code\u003e higher\nup in the if-else chain, but it's something worth keeping in mind.\u003c/p\u003e\n\u003cp\u003eAlso, there's actually two other string types in D, \u003ccode\u003ewstring\u003c/code\u003e and \u003ccode\u003edstring\u003c/code\u003e.\nWhile up to this point I've tried to pretend they don't exist this series still won't be going over\nusing them due to various reasons (such as std.json#JSONValue not supporting them).\u003c/p\u003e\n\u003cp\u003eIn regards to that issue it may be wise to combine std.json#isDynamicArray with a check to make sure\nthe type isn't a \u003ccode\u003ewstring\u003c/code\u003e or \u003ccode\u003edstring\u003c/code\u003e, depending on your circumstances.\u003c/p\u003e\n\u003cp\u003eOther than that, there's not really any other surprises in this code that haven't been seen before -\nunless you're using a super large dataset that causes a bunch of recursive\ncalls that is... so onto deserialising!\u003c/p\u003e\n\u003ch2 id=\"deserialising-dynamic-arrays\"\u003eDeserialising dynamic arrays\u003c/h2\u003e\n\u003cp\u003eReference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{    \n    static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == string))\n    { /**/ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }    \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else\n    { /**/ }\n}    \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgain, there's nothing overly new or complicated about the deserialisation code except for one thing:\nstd.range#ElementType is used to get the type of data stored in the array. Make sure to \u003ccode\u003eimport std.range;\u003c/code\u003e somewhere.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{    \n    static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == string))\n    { /**/ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }    \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else static if(isDynamicArray!T)\n    {\n        T toReturn;\n        \n        alias ElementT = ElementType!T; // E.g. If `T` were `int[]`, then this would be `int`.\n        \n        foreach(element; json.array)\n        {\n            toReturn ~= deserialise!ElementT(element);\n        }\n        \n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs another side note about strings, since they're kind of annoying, \u003ccode\u003eElementType\u003c/code\u003e\nwill \u003cem\u003ealways\u003c/em\u003e return \u003ccode\u003edchar\u003c/code\u003e if used on any kind of string. However \u003ccode\u003eElementEncodingType\u003c/code\u003e\nwill properly return \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003ewchar\u003c/code\u003e, and \u003ccode\u003edchar\u003c/code\u003e for their respective\nstring types.\u003c/p\u003e\n\u003cp\u003eFinally, let's give it a test:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/h7U38W\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto json = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;].serialise();\n    writeln(json); \n    writeln(json.deserialise!(string[]));\n\n    /*\n        Output:\n            [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;]\n            [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"serialising-and-deserialising-associative-arrays-abbreviated-as-aa\"\u003eSerialising and deserialising associative arrays (abbreviated as 'AA')\u003c/h2\u003e\n\u003cp\u003eAs a common theme with this post there's nothing new to explain for AAs, so\nhere's a quick list of noteworthy templates that we're going to use:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003estd.traits#isAssociativeArray to check if a type is an AA.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003estd.traits#KeyType and std.traits#ValueType are used to get what type is used for the AA's key and value, respectively.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe'll use \u003ccode\u003estatic assert\u003c/code\u003e to enforce that the key type is a string.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"serialising\"\u003eSerialising\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else static if(isDynamicArray!T)\n    { /**/ }\n    else static if(isAssociativeArray!T)\n    {\n        JSONValue toReturn;\n        \n        alias KeyT = KeyType!T;\t// E.g. For bool[string] this would evaluate to `string`\n        static assert(is(KeyT == string), \u0026quot;Only string keys are supported, not: \u0026quot; ~ KeyT.stringof);\n        \n        foreach(key, element; value)\n        {\n            toReturn[key] = serialise(element);\n        }\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"deserialising\"\u003eDeserialising\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{    \n    static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == string))\n    { /**/ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }    \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else static if(isDynamicArray!T)\n    { /**/ }\n    else static if(isAssociativeArray!T)\n    {\n        T toReturn;\n        \n        alias KeyT   = KeyType!T;   // bool[string] -\u0026gt; string\n        alias ValueT = ValueType!T; // bool[string] -\u0026gt; bool\n        \n        static assert(is(KeyT == string), \u0026quot;Only string keys are supported, not: \u0026quot; ~ KeyT.stringof);\n        \n        foreach(key, element; json.object)\n        {\n            toReturn[key] = deserialise!ValueT(element);\n        }\n            \n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd of course we should probably test these additions.\u003c/p\u003e\n\u003ch3 id=\"test\"\u003eTest\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/vjcQkc\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto json = \n    [\n        \u0026quot;bradley\u0026quot;: Person(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student), \n        \u0026quot;andy\u0026quot;:    Person(\u0026quot;Andy\u0026quot;, 100, PersonType.Staff)\n    ].serialise();\n\n    writeln(json);\n    writeln(json.deserialise!(Person[string]));\n\n    /*\n        Output:\n            {\u0026quot;andy\u0026quot;:{\u0026quot;age\u0026quot;:100,\u0026quot;name\u0026quot;:\u0026quot;Andy\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;Staff\u0026quot;},\u0026quot;bradley\u0026quot;:{\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;}}\n            [\u0026quot;andy\u0026quot;:Person(\u0026quot;Andy\u0026quot;, 100, Staff), \u0026quot;bradley\u0026quot;:Person(\u0026quot;Bradley\u0026quot;, 20, Student)]\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThis post was a bit short and sweet. There weren't really any new features to explain, mostly just\nnew templates such as std.json#isDynamicArray.\u003c/p\u003e\n\u003cp\u003eWhile this post may have been a bit boring, hopefully the next post, where we explore the use\nof \u003ca href=\"https://dlang.org/spec/attribute.html#uda\"\u003eUDAs\u003c/a\u003e (User Defined Attributes)\nto allow deeper customisation of how things are serialised, will be more interesting.\u003c/p\u003e\n\u003ch2 id=\"excercises\"\u003eExcercises\u003c/h2\u003e\n\u003ch3 id=\"add-support-for-static-arrays\"\u003eAdd support for static arrays\u003c/h3\u003e\n\u003cp\u003eThe main two things you'll need for this are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003estd.traits#isStaticArray to determine whether a type is a static array or not.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAfter you identify a type (\u003ccode\u003eT\u003c/code\u003e) as a static array, you can then be assured that the type will\nhave a constant property called \u003ccode\u003eT.length\u003c/code\u003e, which of course is the length of the array.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSomething to consider is, what if during deserialisation you find that the JSON data has\neither too many or too little values for the array?\u003c/p\u003e\n\u003cp\u003eFor the purposes of this excercise (you may want to do something different for real-world usage):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIf there are too \u003cstrong\u003emany\u003c/strong\u003e values, throw an exception.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf there are \u003cstrong\u003enot enough\u003c/strong\u003e values, fill the empty spaces up with either\n[T.init(https://dlang.org/spec/property.html#init) (for value types),\nor \u003ccode\u003enull\u003c/code\u003e (for reference types).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd finally, here's a test case:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/hjZdpN\nvoid main()\n{\n    import std.format    : format;\n    import std.exception : assertThrown;\n\n    string[2] people;\n    JSONValue json;\n\n    // Serialise\n    people = [\u0026quot;Bradley\u0026quot;, \u0026quot;Andy\u0026quot;];\n    json = people.serialise();\n    assert(json[0].str == \u0026quot;Bradley\u0026quot;, \u0026quot;Got: \u0026quot; ~ json[0].str);\n    assert(json[1].str == \u0026quot;Andy\u0026quot;,    \u0026quot;Got: \u0026quot; ~ json[1].str);\n\n    // Deserialise (exact amount of values wanted)\n    people = json.deserialise!(string[2]);\n    assert(people == [\u0026quot;Bradley\u0026quot;, \u0026quot;Andy\u0026quot;], format(\u0026quot;Got: %s\u0026quot;, people));\n\n    // Deserialise (too many values, so exception should be thrown)\n    json = parseJSON(`[\u0026quot;Bradley\u0026quot;, \u0026quot;Andy\u0026quot;, \u0026quot;Kaiya\u0026quot;]`);\n    assertThrown(json.deserialise!(string[2]), \u0026quot;No exception was thrown\u0026quot;);\n\n    // Deserialise (not enough values, so empty spaces should be `string.init`)\n    json = parseJSON(`[\u0026quot;Bradley\u0026quot;]`);\n    people = json.deserialise!(string[2]);\n    assert(people == [\u0026quot;Bradley\u0026quot;, string.init], format(\u0026quot;Got: %s\u0026quot;, people));\n}\n\u003c/code\u003e\u003c/pre\u003e\n","title":"Serialising arrays","created":"0001-01-01T00:00:00Z","updated":"0001-01-01T00:00:00Z","seoUrl":"","seoTitle":"","seoDescription":""}