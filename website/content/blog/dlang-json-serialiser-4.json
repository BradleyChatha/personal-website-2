{"html":"<p><em>Note that in the previous post, the <code>Person</code> struct was converted into a class</em>\n<em>for testing purposes. From this point on <code>Person</code> is a struct again unless specified otherwise.</em></p><p>One of the final things missing before our serialiser can reach a &quot;minimalistic but useable&quot; state\nis the ability to serialise both dynamic and associative arrays. Static arrays are saved as an excercise\nfor this post.</p><p>I&apos;ve already covered the majority of the main metaprogramming features that&apos;ll be used in this post, and arrays\nare relatively simple to serialise, so this post will be on the shorter end.</p><h2 id=\"serialising-dynamic-arrays\">Serialising dynamic arrays</h2><p>As usual, here&apos;s our current serialise function for reference:</p><pre><code>JSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else\n    { /**/ }\n}    \n</code></pre><p>For dynamic arrays we need to iterate over the array&apos;s elements; serialise\nthem, and then append the serialised value into a JSON array.</p><p>There&apos;s not too much to explain about to code, so I&apos;ll quickly highlight two things:</p><ul><li><p>We use std.traits#isDynamicArray to check if <code>T</code> is a dynamic array.</p></li></ul><ul><li><p>Creating a std.json#JSONValue that is also an array is a bit iffy, using <code>parseJSON(\"[]\")</code> was the cleanest way I could find.\n(std.json is pretty outdated)</p></li></ul><pre><code>JSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else static if(isDynamicArray!T)\n    {\n        JSONValue toReturn = parseJSON(\"[]\");\n        \n        foreach(element; value)\n        {\n            toReturn.array ~= serialise(element);\n        }\n        \n        return toReturn;\n    }\n    else\n    { /**/ }\n} \n</code></pre><p>Do note that <code>string</code> in D is actually just an <code>immutable(char)[]</code>, which\nwould satisfy the std.json#isDynamicArray template.</p><p>This isn&apos;t so much an issue in our case due to the fact we handle <code>string</code> higher\nup in the if-else chain, but it&apos;s something worth keeping in mind.</p><p>Also, there&apos;s actually two other string types in D, <code>wstring</code> and <code>dstring</code>.\nWhile up to this point I&apos;ve tried to pretend they don&apos;t exist this series still won&apos;t be going over\nusing them due to various reasons (such as std.json#JSONValue not supporting them).</p><p>In regards to that issue it may be wise to combine std.json#isDynamicArray with a check to make sure\nthe type isn&apos;t a <code>wstring</code> or <code>dstring</code>, depending on your circumstances.</p><p>Other than that, there&apos;s not really any other surprises in this code that haven&apos;t been seen before - \nunless you&apos;re using a super large dataset that causes a bunch of recursive\ncalls that is... so onto deserialising!</p><h2 id=\"deserialising-dynamic-arrays\">Deserialising dynamic arrays</h2><p>Reference:</p><pre><code>T deserialise(T)(JSONValue json)\n{    \n    static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == string))\n    { /**/ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }    \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else\n    { /**/ }\n}    \n</code></pre><p>Again, there&apos;s nothing overly new or complicated about the deserialisation code except for one thing:\nstd.range#ElementType is used to get the type of data stored in the array. Make sure to <code>import std.range;</code> somewhere.</p><pre><code>T deserialise(T)(JSONValue json)\n{    \n    static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == string))\n    { /**/ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }    \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else static if(isDynamicArray!T)\n    {\n        T toReturn;\n        \n        alias ElementT = ElementType!T; // E.g. If `T` were `int[]`, then this would be `int`.\n        \n        foreach(element; json.array)\n        {\n            toReturn ~= deserialise!ElementT(element);\n        }\n        \n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>As another side note about strings, since they&apos;re kind of annoying, <code>ElementType</code>\nwill <em>always</em> return <code>dchar</code> if used on any kind of string. However <code>ElementEncodingType</code>\nwill properly return <code>char</code>, <code>wchar</code>, and <code>dchar</code> for their respective\nstring types.</p><p>Finally, let&apos;s give it a test:</p><pre><code>// https://godbolt.org/z/h7U38W\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto json = [\"a\", \"b\", \"c\"].serialise();\n    writeln(json); \n    writeln(json.deserialise!(string[]));\n\n    /*\n        Output:\n            [\"a\",\"b\",\"c\"]\n            [\"a\", \"b\", \"c\"]\n    */\n}\n</code></pre><h2 id=\"serialising-and-deserialising-associative-arrays--abbreviated-as--aa--\">Serialising and deserialising associative arrays (abbreviated as &apos;AA&apos;)</h2><p>As a common theme with this post there&apos;s nothing new to explain for AAs, so\nhere&apos;s a quick list of noteworthy templates that we&apos;re going to use:</p><ul><li><p>std.traits#isAssociativeArray to check if a type is an AA.</p></li></ul><ul><li><p>std.traits#KeyType and std.traits#ValueType are used to get what type is used for the AA&apos;s key and value, respectively.</p></li></ul><ul><li><p>We&apos;ll use <code>static assert</code> to enforce that the key type is a string.</p></li></ul><h3 id=\"serialising\">Serialising</h3><pre><code>JSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else static if(isDynamicArray!T)\n    { /**/ }\n    else static if(isAssociativeArray!T)\n    {\n        JSONValue toReturn;\n        \n        alias KeyT = KeyType!T;\t// E.g. For bool[string] this would evaluate to `string`\n        static assert(is(KeyT == string), \"Only string keys are supported, not: \" ~ KeyT.stringof);\n        \n        foreach(key, element; value)\n        {\n            toReturn[key] = serialise(element);\n        }\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><h3 id=\"deserialising\">Deserialising</h3><pre><code>T deserialise(T)(JSONValue json)\n{    \n    static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == string))\n    { /**/ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }    \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    { /**/ }\n    else static if(isDynamicArray!T)\n    { /**/ }\n    else static if(isAssociativeArray!T)\n    {\n        T toReturn;\n        \n        alias KeyT   = KeyType!T;   // bool[string] -> string\n        alias ValueT = ValueType!T; // bool[string] -> bool\n        \n        static assert(is(KeyT == string), \"Only string keys are supported, not: \" ~ KeyT.stringof);\n        \n        foreach(key, element; json.object)\n        {\n            toReturn[key] = deserialise!ValueT(element);\n        }\n            \n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>And of course we should probably test these additions.</p><h3 id=\"test\">Test</h3><pre><code>// https://godbolt.org/z/vjcQkc\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto json = \n    [\n        \"bradley\": Person(\"Bradley\", 20, PersonType.Student), \n        \"andy\":    Person(\"Andy\", 100, PersonType.Staff)\n    ].serialise();\n\n    writeln(json);\n    writeln(json.deserialise!(Person[string]));\n\n    /*\n        Output:\n            {\"andy\":{\"age\":100,\"name\":\"Andy\",\"type\":\"Staff\"},\"bradley\":{\"age\":20,\"name\":\"Bradley\",\"type\":\"Student\"}}\n            [\"andy\":Person(\"Andy\", 100, Staff), \"bradley\":Person(\"Bradley\", 20, Student)]\n    */\n}\n</code></pre><h2 id=\"conclusion\">Conclusion</h2><p>This post was a bit short and sweet. There weren&apos;t really any new features to explain, mostly just\nnew templates such as std.json#isDynamicArray.</p><p>While this post may have been a bit boring, hopefully the next post, where we explore the use\nof <a href=\"https://dlang.org/spec/attribute.html#uda\">UDAs</a> (User Defined Attributes) \nto allow deeper customisation of how things are serialised, will be more interesting.</p><h2 id=\"excercises\">Excercises</h2><h3 id=\"add-support-for-static-arrays\">Add support for static arrays</h3><p>The main two things you&apos;ll need for this are:</p><ul><li><p>std.traits#isStaticArray to determine whether a type is a static array or not.</p></li></ul><ul><li><p>After you identify a type (<code>T</code>) as a static array, you can then be assured that the type will\nhave a constant property called <code>T.length</code>, which of course is the length of the array.</p></li></ul><p>Something to consider is, what if during deserialisation you find that the JSON data has\neither too many or too little values for the array?</p><p>For the purposes of this excercise (you may want to do something different for real-world usage):</p><ul><li><p>If there are too <strong>many</strong> values, throw an exception.</p></li></ul><ul><li><p>If there are <strong>not enough</strong> values, fill the empty spaces up with either\n[T.init(https://dlang.org/spec/property.html#init) (for value types), \nor <code>null</code> (for reference types).</p></li></ul><p>And finally, here&apos;s a test case:</p><pre><code>// https://godbolt.org/z/hjZdpN\nvoid main()\n{\n    import std.format    : format;\n    import std.exception : assertThrown;\n\n    string[2] people;\n    JSONValue json;\n\n    // Serialise\n    people = [\"Bradley\", \"Andy\"];\n    json = people.serialise();\n    assert(json[0].str == \"Bradley\", \"Got: \" ~ json[0].str);\n    assert(json[1].str == \"Andy\",    \"Got: \" ~ json[1].str);\n\n    // Deserialise (exact amount of values wanted)\n    people = json.deserialise!(string[2]);\n    assert(people == [\"Bradley\", \"Andy\"], format(\"Got: %s\", people));\n\n    // Deserialise (too many values, so exception should be thrown)\n    json = parseJSON(`[\"Bradley\", \"Andy\", \"Kaiya\"]`);\n    assertThrown(json.deserialise!(string[2]), \"No exception was thrown\");\n\n    // Deserialise (not enough values, so empty spaces should be `string.init`)\n    json = parseJSON(`[\"Bradley\"]`);\n    people = json.deserialise!(string[2]);\n    assert(people == [\"Bradley\", string.init], format(\"Got: %s\", people));\n}\n</code></pre>","metadata":["dlang-json-serialiser-4","serialise-array-dynamic-static","31-10-2019","Serialising arrays","07-02-2020"],"headers":[{"text":"Serialising dynamic arrays","slug":"serialising-dynamic-arrays","level":2},{"text":"Deserialising dynamic arrays","slug":"deserialising-dynamic-arrays","level":2},{"text":"Serialising and deserialising associative arrays (abbreviated as 'AA')","slug":"serialising-and-deserialising-associative-arrays--abbreviated-as--aa--","level":2},{"text":"Serialising","slug":"serialising","level":3},{"text":"Deserialising","slug":"deserialising","level":3},{"text":"Test","slug":"test","level":3},{"text":"Conclusion","slug":"conclusion","level":2},{"text":"Excercises","slug":"excercises","level":2},{"text":"Add support for static arrays","slug":"add-support-for-static-arrays","level":3}]}