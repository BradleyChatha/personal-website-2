{"html":"<p>In this post we&apos;ll be creating a text template format that is capable of running arbitrary D code, and this is all done at compile-time!</p><p>This post briefly explains D-specific concepts, so even those that don&apos;t know much about D can still read along. Those more familiar with D\nmay not find this post too interesting, but I&apos;d like some feedback via a Github issue if there&apos;s anything that can be improved.</p><h2 id=\"introduction\">Introduction</h2><p>Some projects may find it useful to be able to define external template files for certain needs such as: project scaffolding, HTML templates,\nor whatever you want really!</p><p>While we can (and will) create a simple &quot;Replace $VAR with string&quot; style of text template, we can actually take things one step further with D -\nwe can allow the template to execute arbitrary D code in order to determine some of its values.</p><p>Whether this is a good idea or not is completely up to debate, but this is the groundwork required to make things like ASP&apos;s Razor templates, \nvibe-d&apos;s diet templates, or even just a simple DSL.</p><h2 id=\"basic-format-and-initial-code-setup\">Basic format and initial code setup</h2><p>First of all, let&apos;s run <code>dub init</code> to create a new project, and then let&apos;s also make a folder called &quot;views&quot;. </p><p>The project structure should look something like this:</p><p><a href=\"/img/blogs/meta/meta1_project_structure.webp\">Project Structure</a></p><p>Before we dive into allowing execution of D code, let&apos;s just get the basics done first: Allow the template to define variables, then allow the program\nto fill in those variables with values.</p><p>To keep things simple, variables are just strings that we patch into the template&apos;s text wherever they&apos;re specified.</p><p>This will be the example file we&apos;re working with, and we&apos;ll store this in <code>views/template.txt</code>:</p><pre><code>DECLARE\n    $NAME\n    $AGE\n    $HOBBIES\nSTART\nMy name is $NAME I am $AGE years old and my hobbies are: $HOBBIES\n</code></pre><p>Now let&apos;s open up the <code>source/app.d</code> file, and create the initial structure for our program:</p><pre><code>import std;\n\nstruct Document\n{\n    string[] declaredVariables;\n    string templateText;\n}\n\nstring resolve(string templateName)(string[string] variables)\n{\n    Appender!(char[]) output;\n\n    return output.data.assumeUnique;\n}\n\nDocument parseDocument(string contents)\n{\n    Document doc;\n\n    return doc;\n}\n\nvoid main()\n{\n    writeln(resolve!\"template.txt\"(\n    [\n        \"$NAME\":    \"Bradley\",\n        \"$AGE\":     \"22\",\n        \"$HOBBIES\": \"programming, complaining, and long walks at night.\"\n    ]));\n}\n</code></pre><p>We start off with <code>import std</code> so we have access to the entire standard library.</p><p>The <code>Document</code> struct is used to model our template files. For now we simply have the names of any declared variables, and the text that we need to resolve.</p><p>The <code>resolve</code> function will be performing the actual resolution. It takes <code>templateName</code> as a compile-time parameter, and <code>variables</code> as a runtime one.</p><p>The <code>parseDocument</code> function will parse the template into a <code>Document</code> struct for us.</p><p>And finally, the <code>main</code> function shows how we&apos;re going to be using our <code>resolve</code> function, and also prints its output for us.</p><p>You may have noticed we&apos;re using std.array#Appender:Appender, and std.exception#assumeUnique:assumeUnique. You can click on their links\nif you&apos;re interested in reading about them as these are more an implementation detail rather than anything crucial.</p><h2 id=\"implementing-parsedocument\">Implementing parseDocument</h2><p>Since the focus of this post is more-so the metaprogramming stuff we&apos;ll be doing later, I&apos;ll show you the code for</p><p><code>parseDocument</code>, talk about it a bit, and then we&apos;ll move on as to not spend too much time here.</p><pre><code>Document parseDocument(string contents)\n{\n    enum Mode\n    {\n        none,\n        declare,\n        start\n    }\n\n    Document doc;\n    Mode mode;\n\n    foreach(line; contents.lineSplitter())\n    {\n        switch(mode) with(Mode)\n        {\n            case none:\n                enforce(line == \"DECLARE\", \"Templates must start with 'DECLARE'\");\n                mode = declare;\n                break;\n\n            case declare:\n                if(line == \"START\")\n                {\n                    mode = start;\n                    continue;\n                }\n\n                doc.declaredVariables ~= line.strip(' ');\n                break;\n\n            case start:\n                // This code here is bad, but I wanted to keep things simple.\n                if(doc.templateText.length > 0)\n                    doc.templateText ~= '\\n';\n                doc.templateText ~= line;\n                break;\n\n            default: assert(false);\n        }\n    }\n\n    return doc;\n}\n</code></pre><p>I have decided to use a simple state machine to perform the parsing, whose state is determined by which <code>Mode</code> it&apos;s in. </p><p>D allows functions to have their own classes, structs, enums, etc. which is very useful for cases like this.</p><p>The <code>with(Mode)</code> statement allows us to write <code>Mode.none, Mode.declare, etc.</code> as simply <code>none, declare, etc.</code>, which is very nice when paired with <code>switch</code> statements.</p><p>Also, here&apos;s the documentation for std.exception#enforce if you&apos;d like to read more about it.</p><p>So briefly, foreach line within contents:</p><ul><li><p>If we are not in a mode, ensure that the first line is &quot;DECLARE&quot;, then move into &apos;declare&apos; mode.</p></li></ul><ul><li><p>If we are in declare mode and the line is &quot;START&quot;, move into &apos;start&apos; mode.</p></li></ul><ul><li><p>If we are in declare mode and the line isn&apos;t &quot;START&quot;, trim the spaces from the left and right, and add it into <code>declaredVariables</code>.</p></li></ul><ul><li><p>If we are in start mode then join up all the remaining lines into <code>templateText</code>.</p></li></ul><h2 id=\"implementing-resolve\">Implementing resolve</h2><p>There&apos;s a few things to talk about with this function, but because we haven&apos;t implemented allowing templates to execute code yet, I&apos;ll do the same thing\nas before:</p><pre><code>string resolve(string templateName)(string[string] variables)\n{\n    // The types for these two values were made explicit for the user's comfort.\n    // In general, D can infer types automatically in cases like this, so explicit typing is not needed.\n    const string TEMPLATE_CONTENTS = import(templateName);\n    enum Document Doc = parseDocument(TEMPLATE_CONTENTS);\n    enforce(\n        Doc.declaredVariables.all!(varName => varName in variables), \n        \"Not all declared variables were given a value in 'variables'\"\n    );\n\n    Appender!(char[]) output;\n\n    string text = Doc.templateText;\n    while(text.length > 0)\n    {\n        const nextVarStart = text.indexOf('$');\n        if(nextVarStart < 0)\n        {\n            output.put(text);\n            break;\n        }\n\n        output.put(text[0..nextVarStart]);\n        text = text[nextVarStart..$];\n\n        const nextSpace = text.indexOfAny(\" \\r\\n\");\n        const varName   = (nextSpace < 0) ? text : text[0..nextSpace];\n        text            = (nextSpace < 0) ? null : text[nextSpace..$];\n        output.put(variables[varName]);\n    }\n\n    return output.data.assumeUnique;\n}\n</code></pre><p>To start off, we have the very interesting line of <code>const string TEMPLATE_CONTENTS = import(templateName)</code>.</p><p>Remember how we called one of the folders &quot;views&quot;? This is actually a string import folder that dub automatically tells the compiler about.\nNow remember that in our <code>main</code> function we pass in <code>template.txt</code> as the <code>templateName</code> compile-time parameter?</p><p>Well, the <code>import(string)</code> statement allows us to directly embed a file from the string import folder into our executable, and access it via\na variable, which is <code>TEMPLATE_CONTENTS</code> in this case. So <code>resolve!\"template.txt\"</code> is the user telling us to import the contents of <code>views/template.txt</code>\nso we can process it at compile-time.</p><p>We then come to yet another very interesting line: <code>enum Document Doc = parseDocument(TEMPLATE_CONTENTS);</code>.</p><p>An <code>enum</code> value is called a Manifest Constant. It is a value that has no physical location within your executable, and exists purely at compile-time.\nAny usage of an enum value results in it becoming duplicated wherever it is used, kind of like <code>#define</code> from C/C++.</p><p>The next thing to note is that we&apos;re actually setting the value of <code>Doc</code> to the return result of <code>parseDocument</code>. If you aren&apos;t familiar with D,\nthis is called CTFE - Compile Time Function Execution/Evaluation.</p><p>So in other words, we&apos;re importing the contents of <code>template.txt</code>, and then parsing it into a <code>Document</code> by executing normal D code, <strong>all at compile time</strong>.\nThis is important for when we let templates execute their own code, which we&apos;ll start doing very soon.</p><p>The rest of this function is basically just replacing all instances of <code>$NAME</code> with the value of <code>variables[\"$NAME\"]</code>. You can read through it if you want,\nas I&apos;m not going to explain it line-by-line.</p><h2 id=\"intermission\">Intermission</h2><p>Let&apos;s have a quick <code>dub run</code> of our code, and then move onto the more interesting stuff:</p><pre><code>$> dub run\nMy name is Bradley I am 22 years old and my hobbies are: programming, complaining, and long walks at night.\n</code></pre><p>So with our current code we can import templates and do a basic search-and-replace for things like <code>$NAME</code> using user-provided values.</p><p>We will now add onto our two functions, and also our example file, the ability to compile and run arbitrary D code within our executable.</p><h2 id=\"final-format\">Final format</h2><p>The final format for our text templates will look like this. This is also the contents of <code>views/template.txt</code>:</p><pre><code>DECLARE\n    $NAME\n    $AGE\n    $HOBBIES\nCOMPUTE\n    $HOBBIES_LOUD : variables[\"$HOBBIES\"].splitter(',').map!(str => \"!!!\"~str.strip(' ').toUpper~\"!!!\").fold!((a,b) => a~\", \"~b)\nSTART\nMy name is $NAME I am $AGE years old and my hobbies are: $HOBBIES\n\nIf you couldn't hear me loud enough, my hobbies are: $HOBBIES_LOUD\n</code></pre><p>We have added a new section called &quot;COMPUTE&quot; which contains variables whose values are computed from the specified D code.</p><p>Our <code>$HOBBIES_LOUD</code> variable splits up the <code>$HOBBIES</code> variable by comma, adds &quot;!!!&quot; as a suffix and prefix to each word, then turns all words into upper-case\nbefore joining them back together separated by a comma. It&apos;s not too important what&apos;s there, as long as it&apos;s D code, and as long as it evaluates to a <code>string</code>.</p><h2 id=\"upgrading-document-and-parsedocument\">Upgrading Document and parseDocument</h2><p>We now need to upgrade <code>Document</code> and <code>parseDocument</code> to include our new computed variables. New code is covered in comment lines:</p><pre><code>struct Document\n{\n    string[] declaredVariables;\n    string templateText;\n\n    /////////////////////////////////\n    // Key is var name, value is D code.\n    string[string] computedVariables;\n    /////////////////////////////////\n}\n\nDocument parseDocument(string contents)\n{\n    enum Mode\n    {\n        none,\n        declare,\n        start,\n\n        ///////\n        compute\n        ///////\n    }\n\n    Document doc;\n    Mode mode;\n\n    foreach(line; contents.lineSplitter())\n    {\n        switch(mode) with(Mode)\n        {\n            case none:\n                enforce(line == \"DECLARE\", \"Templates must start with 'DECLARE'\");\n                mode = declare;\n                break;\n\n            case declare:\n                if(line == \"START\")\n                {\n                    mode = start;\n                    continue;\n                }\n                //////////////////////////\n                else if(line == \"COMPUTE\")\n                {\n                    mode = compute;\n                    continue;\n                }\n                //////////////////////////\n\n                doc.declaredVariables ~= line.strip(' ');\n                break;\n\n            ////////////////////////////////////////////////////\n            case compute:\n                if(line == \"START\")\n                {\n                    mode = start;\n                    continue;\n                }\n\n                const colon   = line.indexOf(':');\n                const varName = line[0..colon].strip(' ');\n                const code    = line[colon+1..$].strip(' ');\n                doc.computedVariables[varName] = code;\n                break;\n            ////////////////////////////////////////////////////\n\n            case start:\n                // This code here is bad, but I wanted to keep things simple.\n                if(doc.templateText.length > 0)\n                    doc.templateText ~= '\\n';\n                doc.templateText ~= line;\n                break;\n\n            default: assert(false);\n        }\n    }\n\n    return doc;\n}\n</code></pre><p>In short: </p><ul><li><p>We add <code>computedVariables</code> to <code>Document</code> which is a dictionary where the key is the variable&apos;s name, and the value is the D code.</p></li></ul><ul><li><p>We then add a new &apos;compute&apos; mode for our &quot;COMPUTE&quot; section, which can only be used after the &quot;DECLARE&quot; section.</p></li></ul><ul><li><p>If we are in &apos;compute&apos; mode, then split the line by the first colon - everything on the left is the variable name, everything on the right is the D code to execute.</p></li></ul><h2 id=\"upgrading-resolve\">Upgrading resolve</h2><p>The ultimate question now is: &quot;How on earth do you let external string files execute D code?&quot;.</p><p>This is where the magic happens, and you&apos;ll hopefully be shocked (if you&apos;re new to D) at how simple this is. We are only adding two lines of code:</p><pre><code>string resolve(string templateName)(string[string] variables)\n{\n    const string TEMPLATE_CONTENTS = import(templateName);\n    enum Document Doc = parseDocument(TEMPLATE_CONTENTS);\n    enforce(\n        Doc.declaredVariables.all!(varName => varName in variables), \n        \"Not all declared variables were given a value in 'variables'\"\n    );\n\n    ////////////////////////////////////////////////////\n    static foreach(varName, code; Doc.computedVariables)\n        variables[varName] = mixin(code);\n    ////////////////////////////////////////////////////\n\n    Appender!(char[]) output;\n\n    string text = Doc.templateText;\n    while(text.length > 0)\n    {\n        const nextVarStart = text.indexOf('$');\n        if(nextVarStart < 0)\n        {\n            output.put(text);\n            break;\n        }\n\n        output.put(text[0..nextVarStart]);\n        text = text[nextVarStart..$];\n\n        const nextSpace = text.indexOfAny(\" \\r\\n\");\n        const varName   = (nextSpace < 0) ? text : text[0..nextSpace];\n        text            = (nextSpace < 0) ? null : text[nextSpace..$];\n        output.put(variables[varName]);\n    }\n\n    return output.data.assumeUnique;\n}\n</code></pre><p>The first part is that we&apos;re making use of <a href=\"https://dlang.org/spec/version.html#staticforeach\">static foreach</a>. Without going into too much\ndetail, it is basically a compile-time <code>foreach</code> that duplicates its body into the final code for every value it iterates over. The more technical term is that\nit &quot;unrolls&quot; itself.</p><p>The final part is that we&apos;re using the statement <code>mixin(code)</code>. D has a feature called <a href=\"https://tour.dlang.org/tour/en/gems/string-mixins\">string mixins</a> which will\ninsert a compile-time string into your code, which is then compiled as you&apos;d expect.</p><p>Recall that our <code>enum Document Doc</code> variable is a compile-time-only value because it is marked as an <code>enum</code>. This means we can use the data within this\nvariable directly with compile-time-only constructs such as <code>static foreach</code> and <code>mixin</code>.</p><p>So what our two lines are doing is that they&apos;re literally just taking the code from our template file, mixing them into our <code>resolve</code> function, and then\nthe result of the code is stored under the variable&apos;s name, which the rest of the function will handle for us.</p><p>Let&apos;s have a run:</p><pre><code>$> dub run\nMy name is Bradley I am 22 years old and my hobbies are: programming, complaining, and long walks at night.\n\nIf you couldn't hear me loud enough, my hobbies are: !!!PROGRAMMING!!!, !!!COMPLAINING!!!, !!!AND LONG WALKS AT NIGHT.!!!\n</code></pre><p>And there you have it. D is amazing at writing code that generates code, and you can see for yourself just how simple things are yet how powerful they are\nwhen you combine all of D&apos;s different features together. All without preprocessors or external tooling. All within the same language.</p><p>Now, if you think about it, you technically know enough to start making things like the <a href=\"https://code.dlang.org/packages/pegged\">pegged</a> library - translating\na DSL into fully compiled D code for a specific purpose (i.e. parsing from a grammar). All you need to do is translate something into some D code, then <code>mixin</code>\nsaid code.</p><h2 id=\"having-some-fun\">Having some fun</h2><p>Just for a bit of fun let&apos;s make our template resolve another template. Create another template in <code>views/other.txt</code> and give it these contents:</p><pre><code>DECLARE\n    $HOWDY\nSTART\nHOWDY $HOWDY\n</code></pre><p>Now let&apos;s update our <code>views/template.txt</code>:</p><pre><code>DECLARE\n    $NAME\n    $AGE\n    $HOBBIES\nCOMPUTE\n    $HOBBIES_LOUD : variables[\"$HOBBIES\"].splitter(',').map!(str => \"!!!\"~str.strip(' ').toUpper~\"!!!\").fold!((a,b) => a~\", \"~b)\n    $MYSELF       : readText(\"views/template.txt\")\n    $OTHER        : resolve!(\"other.txt\")([\"$HOWDY\": \"Y'ALL\"])\nSTART\nMy name is $NAME I am $AGE years old and my hobbies are: $HOBBIES\n\nIf you couldn't hear me loud enough, my hobbies are: $HOBBIES_LOUD\n\nI can even print myself!\n$MYSELF\n\nAnd even... other templates:\n$OTHER\n</code></pre><p>And then this gives us the result of:</p><pre><code>My name is Bradley I am 22 years old and my hobbies are: programming, complaining, and long walks at night.\n\nIf you couldn't hear me loud enough, my hobbies are: !!!PROGRAMMING!!!, !!!COMPLAINING!!!, !!!AND LONG WALKS AT NIGHT.!!!\n\nI can even print myself!\n[omitted. Contents of views/template.txt]\n\nAnd even... other templates:\nHOWDY Y'ALL\n</code></pre><h2 id=\"conclusion\">Conclusion</h2><p>To conclude, our program from a high-level point of view is:</p><ul><li><p>Import the contents of a file using D&apos;s <code>import(string)</code> statement.</p></li></ul><ul><li><p>Parse the contents of the file into a struct, stored as a compile-time value, by using D&apos;s <a href=\"https://tour.dlang.org/tour/en/gems/compile-time-function-evaluation-ctfe\">CTFE</a>.</p></li></ul><ul><li><p>Generate code for each &quot;compute variable&quot; inside the template using D&apos;s <code>static foreach</code>.</p></li></ul><ul><li><p>Mixin external/processed strings as code using D&apos;s <code>mixin(string)</code> statement.</p></li></ul><ul><li><p>Do other faff at runtime that we only slightly care about compared to the above.</p></li></ul><p>I hope this has been interesting for at least a few readers, and this particular blog series is about one-off posts like this that shows how D can be used to\nmake your life just a little bit easier/fancier.</p>","metadata":["This post covers how you can make a text template format that can even execute D code to generate its values. All at compile time. All in one language.","dlang-compile-time-text-templates","dlang-metaprogramming-text-template-compile-time","01-05-2021","Text templates that can execute code at compile-time","01-05-2021"],"headers":[{"text":"Introduction","slug":"introduction","level":2},{"text":"Basic format and initial code setup","slug":"basic-format-and-initial-code-setup","level":2},{"text":"Implementing parseDocument","slug":"implementing-parsedocument","level":2},{"text":"Implementing resolve","slug":"implementing-resolve","level":2},{"text":"Intermission","slug":"intermission","level":2},{"text":"Final format","slug":"final-format","level":2},{"text":"Upgrading Document and parseDocument","slug":"upgrading-document-and-parsedocument","level":2},{"text":"Upgrading resolve","slug":"upgrading-resolve","level":2},{"text":"Having some fun","slug":"having-some-fun","level":2},{"text":"Conclusion","slug":"conclusion","level":2}]}