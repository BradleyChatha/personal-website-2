{"uid":"dlang-json-serialiser-1-1","html":"\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThis post is an optional post, meaning you can skip this post without it being\ndetrimental for viewing future posts, and simply exists as an aside \u0026quot;FYI\u0026quot;.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eFor convenience here's a shortened version of the \u003ccode\u003edeserialise\u003c/code\u003e\nfunction that was created in the first post of this series.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /**/ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }\n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else\n    {\n        static assert(false, \u0026quot;Don't know how to deserialise type: \u0026quot; ~ T.stringof);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis kind of 'design' being used here is to have a singular template function\n(\u003ccode\u003edeserialise\u003c/code\u003e) that takes any type as its input, and then leverage \u003ccode\u003estatic if\u003c/code\u003e to determine\nthe actual functionality.\u003c/p\u003e\n\u003cp\u003eWhat if we could write this another way? First, we need to know about template constraints.\u003c/p\u003e\n\u003ch2 id=\"template-constraints\"\u003eTemplate constraints\u003c/h2\u003e\n\u003cp\u003eInstead of a function that can take any type, imagine that we instead of multiple seperate \u003cem\u003etemplated\u003c/em\u003e functions that\ncan only take certain types (e.g. only integers, but any kind of integer).\u003c/p\u003e\n\u003cp\u003eWhile we could go the route of nesting a bunch of \u003ccode\u003estatic ifs\u003c/code\u003e inside the function's body\nfollowed by a \u003ccode\u003estatic assert\u003c/code\u003e should all of these \u003ccode\u003eifs\u003c/code\u003e fail, what if instead\nwe tell the compiler the \u003cem\u003eexact\u003c/em\u003e conditions needed for it to even consider using the template function?\u003c/p\u003e\n\u003cp\u003eI feel an example will help clear things up:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid someFunc(T)(T value)\nif(is(T == string) || is(T == long))\n{\n    // Do stuff.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo what's happening here is that we're creating a template function called \u003ccode\u003esomeFunc\u003c/code\u003e\nwhich takes a type parameter (\u003ccode\u003eT\u003c/code\u003e), and it does stuff, similar to the other template functions we've made so far.\u003c/p\u003e\n\u003cp\u003eHowever, take note that we can actually attach an \u003ccode\u003eif\u003c/code\u003e statement \u003cem\u003edirectly to the function's signature\u003c/em\u003e.\nThis is known as a constraint which you can imagine as a \u003ccode\u003estatic if\u003c/code\u003e that applies for the entire function as a whole.\u003c/p\u003e\n\u003cp\u003eThe constraint's condition must pass the given template parameters, otherwise the compiler will refuse to use it for\nthat specific permutation.\u003c/p\u003e\n\u003cp\u003eFor example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://run.dlang.io/is/bYQUBq\nvoid main()\n{\n    someFunc!long(200);              // Fine\n    someFunc!string(\u0026quot;Hello world!\u0026quot;); // Fine\n    someFunc!bool(false);            // Error (see comment below)\n\n    // The error given is:\n    /*\n    onlineapp.d(5): Error: template instance onlineapp.someFunc!bool does not match template declaration someFunc(T)(T value)\n      with T = bool\n      must satisfy one of the following constraints:\n           is(T == string)\n           is(T == long)\n    */\n}\n\nvoid someFunc(T)(T value)\nif(is(T == string) || is(T == long))\n{\n    import std.stdio : writeln;\n    writeln(T.stringof);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo where am I going with this?\u003c/p\u003e\n\u003ch2 id=\"using-constraints-to-create-template-overloads\"\u003eUsing constraints to create template overloads\u003c/h2\u003e\n\u003cp\u003eBy using constraints, we can essentially create overloads for template functions.\u003c/p\u003e\n\u003cp\u003eTake these two functions for example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid someFunc(T)(T value)\nif(is(T == string))\n{\n    // stuff with strings\n}\n\nvoid someFunc(T)(T value)\nif(is(T == long))\n{\n    // stuff with longs\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThey both have the same name, same template parameters, and same runtime parameters. The\nonly difference are their constraints.\u003c/p\u003e\n\u003cp\u003eWhen calling a template function with overloads like this, the compiler will try to match\neach overload with the parameters that you pass to it (which includes testing the constraints).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIf no overloads matches your parameters, the compile fails.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf more than one overload matches your parameters, the compile fails due to ambiguity.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf exactly one overload matches your parameters, that overload will be used.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo it's pretty much the same as overloading a non-templated function, except we have more specific\ncontrol on when each overload can be used thanks to constraints.\u003c/p\u003e\n\u003cp\u003eWhat this means is that instead of a singular \u003ccode\u003edeserialise\u003c/code\u003e function with a bunch\nof \u003ccode\u003estatic ifs\u003c/code\u003e, you could also/instead use seperate overloads for each type\nof data you want to deserialise:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// For strings\nstring deserialise(T)(JSONValue json)\nif(is(T == string))\n{ /*code here*/ }\n\n// For floats and doubles\nT deserialise(T)(JSONValue json)\nif(isFloatingPoint!T)\n{ /*code here*/ }\n\n// Using both constraints, and static if chains\nT deserialise(T)(JSONValue json)\nif(isIntegral!T)\n{\n    static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n}\n\n// etc.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThere are pros and cons to both designs, and there are of course more complicated ways/features\nthat can be used to design your code around templates that need to discriminate by things like types.\u003c/p\u003e\n\u003cp\u003eHowever, the main point of this one-off post was just to show and explain a different way\nof doing things, so that it doesn't seem like a nested web of \u003ccode\u003estatic ifs\u003c/code\u003e is the only\nway to handle something like this.\u003c/p\u003e\n\u003cp\u003eD will let you mold your code to the exact vision (or close enough to it) of how you want your API to look\nwithout compromising on maintainability.\u003c/p\u003e\n","title":"Serialising basic D types - Alternative function layout","created":"0001-01-01T00:00:00Z","updated":"0001-01-01T00:00:00Z","seoUrl":"","seoTitle":"","seoDescription":""}