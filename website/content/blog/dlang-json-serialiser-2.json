{"uid":"dlang-json-serialiser-2","html":"\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThe ability to serialiser basic types is fun and all, but it's not \u003cem\u003euseful\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eNaturally this means that the next step is to be able to serialise entire structs, which is actually somewhat useful.\nWhile the end result of this serialiser is going to be relatively simple, this series\nof posts should get you started with the knowledge you need to tailor it to your taste.\u003c/p\u003e\n\u003ch2 id=\"static-foreach\"\u003estatic foreach\u003c/h2\u003e\n\u003cp\u003eBefore we can start with structs there are a few features that need a dedicated explanation. One of these\nfeatures being \u003ccode\u003estatic foreach\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003estatic foreach\u003c/code\u003e is a special compile-time-only version of a normal \u003ccode\u003eforeach\u003c/code\u003e\nloop. Like all compile time constructs, it can only access data that exists at compile time.\u003c/p\u003e\n\u003cp\u003eA few things to note about \u003ccode\u003estatic foreach\u003c/code\u003e are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIt does \u003cstrong\u003enot\u003c/strong\u003e create a scope\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIt is 'unrolled' at compile time\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you're confused about these points, please consider this code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid main()\n{\n    import std.stdio : writeln;\n\n    static foreach(number; [1, 2, 3, 4, 5])\n    {\n        writeln(number);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen I say that a \u003ccode\u003estatic foreach\u003c/code\u003e is 'unrolled' it means that the loop\nis executed during compliation, and that the compiler will essentially copy-paste its body for each\niteration of the loop.\u003c/p\u003e\n\u003cp\u003eFor example, the above example would unroll into the following code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid main()\n{\n    import std.stdio : writeln;\n\n    writeln(1);\n    writeln(2);\n    writeln(3);\n    writeln(4);\n    writeln(5);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, as I mentioned a \u003ccode\u003estatic foreach\u003c/code\u003e won't create a scope, which can cause\nissues once we start using variables:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid main()\n{\n    import std.stdio : writeln;\n\n    static foreach(number; [1, 2, 3])\n    {\n        int veryComplexEquation = number + number;\n        writeln(veryComplextEquation);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnrolls to:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid main()\n{\n    import std.stdio : writeln;\n\n    int veryComplexEquation = 1 + 1;\n    writeln(veryComplextEquation);\n\n    // Error: Redefining variable 'veryComplexEquation'\n    int veryComplexEquation = 2 + 2;\n    writeln(veryComplextEquation);\n\n    // Error: Redefining variable 'veryComplexEquation'\n    int veryComplexEquation = 3 + 3;\n    writeln(veryComplextEquation);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see because we don't create a scope, and we use a variable inside\nthe \u003ccode\u003estatic foreach\u003c/code\u003e, the variable we use is defined multiple times\nwhich causes a compiler error.\u003c/p\u003e\n\u003cp\u003eWhile in this case we could just define our variable outside the loop, this isn't\nalways possible/clean to do so we will instead want to create a scope inside each\nunrolling of the \u003ccode\u003estatic foreach\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis is blindingly easy, instead of using singular curly braces ({ and }), double\nthem up instead ({{ and }}):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid main()\n{\n    import std.stdio : writeln;\n\n    static foreach(number; [1, 2, 3])\n    {{\n        int veryComplexEquation = number + number;\n        writeln(veryComplextEquation);\n    }}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnrolls to:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid main()\n{\n    import std.stdio : writeln;\n\n    {\n        int veryComplexEquation = 1 + 1;\n        writeln(veryComplextEquation);\n    }\n\n    {\n        int veryComplexEquation = 2 + 2;\n        writeln(veryComplextEquation);\n    }\n\n    {\n        int veryComplexEquation = 3 + 3;\n        writeln(veryComplextEquation);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd that's basically all you need to do to create a scope.\nIf it's not too clear how this is working, put the extra set of curly braces\non their own lines, and it might make more sense. It's worth noting this is also\nhow you can create a scope with \u003ccode\u003estatic if\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"aliases\"\u003ealiases\u003c/h2\u003e\n\u003cp\u003eAn \u003ccode\u003ealias\u003c/code\u003e is similar to a \u003ccode\u003etypedef\u003c/code\u003e from the C/C++ world but\ninstead of defining an entirely new type you, as the name suggests, create an alias to it instead.\nAliases can be used with any symbol (e.g. functions), not just types.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estruct SomeStruct\n{\n    int a;\n}\n\nalias SStruct = SomeStruct;\n\nvoid main()\n{\n    // Since it's just an alias, we can do things like \u0026quot;set alias to original type\u0026quot;,\n    // because they're literally the same thing.\n    SStruct a = SomeStruct(200);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"manifest-constants-and-their-ability-to-be-templates\"\u003eManifest constants and their ability to be templates\u003c/h2\u003e\n\u003cp\u003eThis often seems to confuse people at first, especially those coming from other languages.\u003c/p\u003e\n\u003cp\u003eA manifest constant can be seen as an immutable variable that exists only at compile time,\nand that any uses of it inside of runtime portions of the code will cause the constant to duplicate\nits value ('manifest') every time it is used.\u003c/p\u003e\n\u003cp\u003eManifest constants are defined and used like a normal variable, except they are prefixed\nby \u003ccode\u003eenum\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum float PI = 3.14;\n\n// Alternatively, let the compiler figure out the type by omitting the type completely.\nenum AGE = 200;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThey are a very important and useful in template code as they effectively act as\ncompile-time only variables, and are in fact one of the few ways to store values computed\nat compile time while still allowing things like \u003ccode\u003estatic if\u003c/code\u003e the ability to access them.\u003c/p\u003e\n\u003cp\u003eBe warned that there are \u003ca href=\"https://wiki.dlang.org/Declaring_constants#Caveats\"\u003ecaveats\u003c/a\u003e\nto them when arrays are used, due to their nature of duplicating their value.\u003c/p\u003e\n\u003cp\u003eOne very interesting feature of manifest constants is that they can actually be templates.\u003c/p\u003e\n\u003cp\u003eThis allows for some interesting usages. For example, the templates we were using from\nstd.traits are all templated enums, which means we could even implement our own versions of templates like\nstd.traits#isBoolean  :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// I should note that std.traits.isBoolean does a bit more than this\n// but that's besides the point.\nenum myIsBoolean(T) = is(T == bool);\n\nenum isStringABoolean  = myIsBoolean!string; // false\nenum isBooleanABoolean = myIsBoolean!bool;   // true\n\nstatic assert(!isStringABoolean);\nstatic assert(isBooleanABoolean);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"serialising-a-struct\"\u003eSerialising a struct\u003c/h2\u003e\n\u003cp\u003eJust as a reminder, here's our \u003ccode\u003eserialise\u003c/code\u003e function at the moment. Appreciate its\ncuteness while it lasts:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{\n    return JSONValue(value);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt's very simple and boring right now, effectively serving as a renamed constructor for \u003ccode\u003eJSONValue\u003c/code\u003e.\nThat's going to be changing of course.\u003c/p\u003e\n\u003cp\u003eThe first thing we want to do is bring in a \u003ccode\u003estatic if\u003c/code\u003e chain, so we\ncan show the user a custom message if they pass in something we can't handle yet.\nJust like we do with the \u003ccode\u003edeserialise\u003c/code\u003e function.\u003c/p\u003e\n\u003ch3 id=\"serialisation---type-checking\"\u003eSerialisation - Type checking\u003c/h3\u003e\n\u003cp\u003eAt the moment let's just check if the value is a primitive type (bool, number, or string).\u003c/p\u003e\n\u003cp\u003eIf we were to just stuff a single \u003ccode\u003estatic if\u003c/code\u003e with all of these checks it'd be\na bit ugly to look at, not to mention annoying to maintain if we needed to reuse the checks\nin another part of the code.\u003c/p\u003e\n\u003cp\u003eSo instead, let's create a templated enum to make the code performing these\nchecks cleaner to use.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum isPrimitiveType(T) = isNumeric!T || is(T == bool) || is(T == string);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, let's modify our \u003ccode\u003eserialise\u003c/code\u003e function to spit out an error\nif this check fails:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum isPrimitiveType(T) = isNumeric!T || is(T == bool) || is(T == string);\n\nJSONValue serialise(T)(T value)\n{\n    static if(isPrimitiveType!T)\n    {\n        return JSONValue(value);\n    }\n    else\n    {\n        static assert(false, \u0026quot;Don't know how to serialise type: \u0026quot; ~ T.stringof);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMuch cleaner than stuffing the all of the type checks into a single \u003ccode\u003estatic if\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"serialisation---iterating-over-a-structs-members\"\u003eSerialisation - Iterating over a struct's members\u003c/h3\u003e\n\u003cp\u003eTo start we'll a \u003ccode\u003estatic if\u003c/code\u003e for structs, and simply return an empty json value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{\n    static if(isPrimitiveType!T)\n    { /**/ }\n    else static if(is(T == struct))\n    {\n        JSONValue toReturn;\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we need a struct that we want to test with, so let's create one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estruct Person \n{\n    string name;\n    uint age;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eserialise\u003c/code\u003e function now requires the ability to inspect each member of the\nstruct, so it can determine what to do with them.\u003c/p\u003e\n\u003cp\u003eStructs and classes in D have a special \u003ccode\u003e.tupleof\u003c/code\u003e property, which returns\na special kind of compile time tuple (think of an immutable array that can contain\ndifferent types of data, including symbols) that contains all of the fields for the\nstruct/class.\u003c/p\u003e\n\u003cp\u003eSo if we combine \u003ccode\u003e.tupleof\u003c/code\u003e and \u003ccode\u003estatic foreach\u003c/code\u003e together then we can effectively create\nspecialised code for each member field in the struct.\u003c/p\u003e\n\u003cp\u003eTo make this more clear we can start off by creating an \u003ccode\u003ealias\u003c/code\u003e to the\nmember's type, then use \u003ccode\u003epragma(msg)\u003c/code\u003e (akin to a compile-time std.stdio#writeln )\nto print out the name of the type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://run.dlang.io/is/NbfZ9i\nJSONValue serialise(T)(T value)\n{\n    /* omitted for brevity */\n    else static if(is(T == struct))\n    {\n        JSONValue toReturn;\n\n        // Note that we're using double braces, so we can have a scope.\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            pragma(msg, MemberType.stringof);\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith the simple output of:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estring\nint\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhile we now have the type of the member, which we're not going to use until a bit later,\nwe also want to know the name of the member since otherwise we don't have a name to store its value with in JSON.\u003c/p\u003e\n\u003cp\u003eTo do this, we can use one of the special\n\u003ca href=\"https://dlang.org/spec/traits.html\"\u003e__traits()\u003c/a\u003e\nwhich exposes many different characteristics about symbols.\u003c/p\u003e\n\u003cp\u003eFor the case of getting the name of something, we can employ the use of\n\u003ca href=\"https://dlang.org/spec/traits.html#identifier\"\u003e__traits(identifier)\u003c/a\u003e, which when\ngiven a symbol will return its name. This is different from \u003ccode\u003e.stringof\u003c/code\u003e\nas that only works on types.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://run.dlang.io/is/ptqEnV\nJSONValue serialise(T)(T value)\n{\n    /* omitted for brevity */\n    else static if(is(T == struct))\n    {\n        JSONValue toReturn;\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n\n            // Much like `enum`, the compiler can figure out that the type is a string here\n            const MemberName = __traits(identifier, member);\n\n            pragma(msg, MemberName ~ \u0026quot; is a \u0026quot; ~ MemberType.stringof);\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich outputs:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename is a string\nage is a int\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"serialisation---serialising-each-member-and-string-mixins\"\u003eSerialisation - Serialising each member, and string mixins\u003c/h3\u003e\n\u003cp\u003eNow that we have the name, type, and ability\nto iterate each member of a struct, we finally have all the information needed\nto be able to serialise each member into our \u003ccode\u003etoReturn\u003c/code\u003e value.\u003c/p\u003e\n\u003cp\u003eThis is a fairly straight forward process: all we need to do is pass each member\nto \u003ccode\u003eserialise\u003c/code\u003e as that already has all the logic in place,\nand then place the return value into the \u003ccode\u003etoReturn\u003c/code\u003e value\nwith the member's name as the key and the return value as the value.\u003c/p\u003e\n\u003cp\u003eThere's one thing you might be wondering however - how do I\nactually \u003cem\u003eaccess\u003c/em\u003e the member using the \u003ccode\u003evalue\u003c/code\u003e\nparameter that gets passed to the function.\u003c/p\u003e\n\u003cp\u003eThe answer here, is to use a string \u003ca href=\"https://dlang.org/articles/mixin.html\"\u003emixin\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eA string mixin is similar to the \u003ccode\u003e#define\u003c/code\u003e directive in C/C++ land\nin that it can be used to turn a string into code,\nexcept mixins are more limited in where you can place it yet more powerful by the fact\nit uses strings directly.\u003c/p\u003e\n\u003cp\u003eSo basically, we have our \u003ccode\u003evalue\u003c/code\u003e parameter, and we have the \u003ccode\u003eMemberName\u003c/code\u003e\nof each member of the value. By combining the two together in a mixin we can\nget access to the member's value during runtime.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMemberType memberValue = mixin(\u0026quot;value.\u0026quot; ~ MemberName);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich compiles into:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// For Person.name\nstring memberValue = value.name;\n\n// For Person.age\nint memberValue = value.age;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRelatively easy, right?\u003c/p\u003e\n\u003cp\u003eAnyway, all that's left to do is to serialise the \u003ccode\u003ememberValue\u003c/code\u003e and place it\ninto the \u003ccode\u003etoReturn\u003c/code\u003e value under the member's name.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{\n    /* omitted for brevity */\n    else static if(is(T == struct))\n    {\n        JSONValue toReturn;\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = mixin(\u0026quot;value.\u0026quot; ~ MemberName);\n\n            // toReturn is a JSON object. Use MemberName as the key. Serialise memberValue as the value.\n            toReturn[MemberName] = serialise(memberValue);\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow comes the time to test it!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://run.dlang.io/is/1WtNd0\nvoid main()\n{\n    import std.stdio;\n    \n    // Instead of specifying the type ourselves as JSONValue, we can\n    // instead use `auto`, which lets the compiler do it for us.\n    auto json = serialise(Person(\u0026quot;Bradley\u0026quot;, 20));\n    writeln(json);\n\n    /*\n    Output:\n        {\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;}\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSuccess!\u003c/p\u003e\n\u003ch2 id=\"deserialising-a-struct\"\u003eDeserialising a struct\u003c/h2\u003e\n\u003cp\u003eFor reference, this is what the \u003ccode\u003edeserialise\u003c/code\u003e function\nlooks like at the moment:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    {\n        return json.str;\n    }\n    else static if(is(T == bool))\n    {\n        return json.boolean;\n    }\n    else static if(isFloatingPoint!T)\n    {\n        return json.floating.to!T();\n    }    \n    else static if(isSigned!T)\n    {\n        return json.integer.to!T();\n    }\n    else static if(isUnsigned!T)\n    {\n        return json.uinteger.to!T();\n    }\n    else\n    {\n        static assert(false, \u0026quot;Don't know how to deserialise type: \u0026quot; ~ T.stringof);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo be honest this is pretty much the exact same process, so\nhere's the code needed for our \u003ccode\u003edeserialise\u003c/code\u003e function\nand I'll point out the differences afterwards.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{\n    /* omitted for brevity */\n    else static if(is(T == struct))\n    {\n        T toReturn;\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = deserialise!MemberType(json[MemberName]);\n\n            // Since the mixin is the *entire* statement, we need to also include a semi-colon in the mixin.\n            mixin(\u0026quot;toReturn.\u0026quot; ~ MemberName ~ \u0026quot; = memberValue;\u0026quot;);\n            // e.g\n            // toReturn.name = memberValue;\n            // toReturn.age = memberValue;\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSee how such (relatively) simple concepts (\u003ccode\u003estatic if/foreach\u003c/code\u003e, \u003ccode\u003e__traits\u003c/code\u003e, \u003ccode\u003emixin\u003c/code\u003e, etc.) can be\nbrought together to allow \u003cem\u003eeasy yet powerful\u003c/em\u003e code generation? This is in my opinion one of D's main selling points.\u003c/p\u003e\n\u003cp\u003eAnyway, here are the main differences:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe type of \u003ccode\u003etoReturn\u003c/code\u003e is now \u003ccode\u003eT\u003c/code\u003e, the struct we're deserialising\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ememberValue uses \u003ccode\u003ejson[MemberName]\u003c/code\u003e to get the JSON version of the value,\nthen calls \u003ccode\u003edeserialise\u003c/code\u003e to turn it into a \u003ccode\u003eMemberType\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe use a string mixin to generate the code to assign the value inside of \u003ccode\u003etoReturn\u003c/code\u003e\nto the deserialised \u003ccode\u003ememberValue\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet's give it a test:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://run.dlang.io/is/nCESzP\nvoid main()\n{\n    import std.stdio : writeln;\n    \n    auto json = serialise(Person(\u0026quot;Bradley\u0026quot;, 20));\n    writeln(\u0026quot;As JSON: \u0026quot;, json);\n    \n    // writeln can pretty-print structs thanks to the same features we just used.\n    auto person = deserialise!Person(json);\n    writeln(\u0026quot;As Person: \u0026quot;, person);\n\n    /*\n    Output:\n        As JSON: {\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;}\n        As Person: Person(\u0026quot;Bradley\u0026quot;, 20)\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWe now have a slightly more useful serialiser due to the newly added\nability to serialise and deserialise structs.\u003c/p\u003e\n\u003cp\u003eIf the ease and simplicity of what this code can accomplish doesn't open your eyes\nto the capabilities of D's metaprogramming, then I advise you to go to a local \u003ca href=\"https://forum.dlang.org/\"\u003eD\nshelter\u003c/a\u003e to pet and play with some lonely \u003cstrong\u003eD\u003c/strong\u003eevelopers ;).\u003c/p\u003e\n\u003ch2 id=\"excercises\"\u003eExcercises\u003c/h2\u003e\n\u003ch3 id=\"excercise-1---more-validation\"\u003eExcercise #1 - More validation\u003c/h3\u003e\n\u003cp\u003eFairly similar to the excercise from the previous post.\u003c/p\u003e\n\u003cp\u003eBasically, in the \u003ccode\u003edeserialise\u003c/code\u003e function ensure that the\n\u003ccode\u003ejson\u003c/code\u003e value passed to the function is an object, and not something\nlike a string or int.\u003c/p\u003e\n\u003cp\u003eThen, before you deserialise a member, check that it actually exists first inside\nof the json value, and throw an exception otherwise.\u003c/p\u003e\n\u003cp\u003eYou can use the \u003ccode\u003ein\u003c/code\u003e operator on \u003ccode\u003eJSONValues\u003c/code\u003e, which\nreturns a pointer, e.g. \u003ccode\u003eJSONValue* ptr = (\u0026quot;name\u0026quot; in json);\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eIf this pointer is \u003ccode\u003enull\u003c/code\u003e, then the key doesn't exist. If it does exist,\nthen you can continue with the deserialisation.\u003c/p\u003e\n\u003cp\u003eLike before, while \u003ccode\u003eJSONValue\u003c/code\u003e will technically do this for you, it's a good way to\npractice checking for and handling things like this.\u003c/p\u003e\n\u003cp\u003eTest case:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://run.dlang.io/is/HhxkdZ\nvoid main()\n{\n    import std.exception : assertThrown, assertNotThrown;\n\n    JSONValue json;\n    json[\u0026quot;age\u0026quot;] = JSONValue(200);\n\n    assertThrown(json.deserialise!Person());\n    assertThrown(JSONValue(null).deserialise!Person());\n\n    json[\u0026quot;name\u0026quot;] = JSONValue(\u0026quot;Bradley\u0026quot;);\n    assertNotThrown(json.deserialise!Person());\n}\n\u003c/code\u003e\u003c/pre\u003e\n","title":"Serialising structs","created":"0001-01-01T00:00:00Z","updated":"0001-01-01T00:00:00Z","seoUrl":"","seoTitle":"","seoDescription":""}