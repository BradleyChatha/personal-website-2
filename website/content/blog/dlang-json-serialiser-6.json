{"uid":"dlang-json-serialiser-6","html":"\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eThis post concludes this short tutorial series by exploring the options that \u003ca href=\"https://dlang.org/spec/template-mixin.html\"\u003emixin templates\u003c/a\u003e\ncan provide us.\u003c/p\u003e\n\u003cp\u003eThe code we create in this post won't be very practical (quite the opposite), however it will show you more magical non-sense\nthat can be achieved with D, and can serve as a basis for your future code. :)\u003c/p\u003e\n\u003ch2 id=\"why-use-and-what-is-a-mixin-template\"\u003eWhy use and what is a \u003ccode\u003emixin template\u003c/code\u003e?\u003c/h2\u003e\n\u003cp\u003eA \u003ccode\u003emixin template\u003c/code\u003e is a way to create a block of code that we can then \u0026quot;copy \u0026amp; paste\u0026quot; into\nother pieces of code. It can be used as a way to automate the generation of boilerplate code, since the full\nfeatures of D (especially \u003ccode\u003estatic if\u003c/code\u003e and string mixins) are available for it to use.\u003c/p\u003e\n\u003cp\u003eIn the context of our serialiser, we could create a \u003ccode\u003emixin template\u003c/code\u003e to automatically generate the static \u003ccode\u003edeserialise\u003c/code\u003e function\nthat our deserialiser has support for (created in \u003ca href=\"/BlogPost/JsonSerialiser/3-serialise-enum-class-dlang-tutorial-metaprogramming\"\u003epost 3\u003c/a\u003e).\u003c/p\u003e\n\u003ch2 id=\"creating-a-class-to-test-with\"\u003eCreating a class to test with\u003c/h2\u003e\n\u003cp\u003eFor reasons I'll make clear shortly, the function we're generating will only support classes, so let's go ahead and make one for us to play with!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass PersonClass\n{\n    private\n    {\n        string name;\n        int age;\n        PersonType type;\n    }\n\n    this()\n    {\n    }\n\n    this(string name, int age, PersonType type)\n    {\n        this.name = name;\n        this.age = age;\n        this.type = type;\n    }\n\n    override string toString()\n    {\n        import std.format : format;\n        return \u0026quot;I am %s, I am %s years old, and I'm a %s.\u0026quot;.format(this.name, this.age, this.type);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"creating-and-using-a-mixin-template\"\u003eCreating and using a \u003ccode\u003emixin template\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eThe most basic form of a \u003ccode\u003emixin template\u003c/code\u003e is really simple. Take note that this one is named \u003ccode\u003eAutoStaticDeserialise\u003c/code\u003e, as this is\nessentially the purpose of this \u003ccode\u003emixin template\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// You can define template parameters in the parenthesis, just like you would for a templated function.\nmixin template AutoStaticDeserialise()\n{\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo make use of our mixin, we simply have to add the following line into our \u003ccode\u003ePersonClass\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass PersonClass\n{\n    mixin AutoStaticDeserialise;\n\n    // omitted...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd now once we've added some code into the \u003ccode\u003emixin template\u003c/code\u003e, it'll start having an effect on our \u003ccode\u003ePersonClass\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"an-interesting-property-of-mixin-template\"\u003eAn interesting property of \u003ccode\u003emixin template\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eAn interesting, and very useful property of \u003ccode\u003emixin template\u003c/code\u003e is that, as stated before, the code inside it is functionally\n\u0026quot;copy \u0026amp; pasted\u0026quot; into its location.\u003c/p\u003e\n\u003cp\u003eLet me show you how we can test this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/6gWC2B\n\nmixin template AutoStaticDeserialise()\n{\n    private alias ThisType = typeof(this);\n    \n    pragma(msg, ThisType);\n}\n\nclass PersonClass\n{\n    mixin AutoStaticDeserialise;\n\n    private\n    {\n        string name;\n        // omitted...\n    }\n    // omitted...\n}\n\n/*\n    Output:  \n        PersonClass\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo explain - since the code has been 'pasted' into \u003ccode\u003ePersonClass\u003c/code\u003e, the expression \u003ccode\u003etypeof(this)\u003c/code\u003e evaluates to the type\nthat has used our mixin, which is \u003ccode\u003ePersonClass\u003c/code\u003e in this case.\u003c/p\u003e\n\u003cp\u003eA more important point is, this means we can even access \u003cem\u003eprivate\u003c/em\u003e members of the type the template is being mixed in to. Take notice\nthat \u003ccode\u003ePersonClass\u003c/code\u003e has some private variables, and I'm sure you can see where this is going.\u003c/p\u003e\n\u003ch2 id=\"adding-some-compile-time-checks\"\u003eAdding some compile-time checks\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003edeserialise\u003c/code\u003e function we're generating isn't actually all that important for the purpose of this post. This post is simply to teach\nabout \u003ccode\u003emixin template\u003c/code\u003e, so we're going to generate a rather useless \u003ccode\u003edeserialise\u003c/code\u003e function just so we have something there at all.\u003c/p\u003e\n\u003cp\u003eTherefor, our \u003ccode\u003edeserialise\u003c/code\u003e function will only work for classes, and will require a default constructor in order to function, so let's\nadd in a few \u003ccode\u003estatic asserts\u003c/code\u003e to enforce this behaviour:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emixin template AutoStaticDeserialise()\n{\n    private alias ThisType = typeof(this);\n    static assert(is(ThisType == class), \u0026quot;This mixin only works with classes.\u0026quot;);\n    static assert(HasDefaultCtor!ThisType, \u0026quot;This function relies on the class having a default constructor.\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"creating-the-deserialise-function\"\u003eCreating the \u003ccode\u003edeserialise\u003c/code\u003e function\u003c/h2\u003e\n\u003cp\u003eI'm not going to waste much time explaining this code, as it is quite literally a very gutted version of the\nstruct/class deserialisation branch that we've already created in our deserialiser.\u003c/p\u003e\n\u003cp\u003eThe main thing to note is that we can directly modify the private variables of the class due to the \u0026quot;copy \u0026amp; paste\u0026quot; property\nof mixin templates.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emixin template AutoStaticDeserialise()\n{\n    private alias ThisType = typeof(this);\n    static assert(is(ThisType == class), \u0026quot;This mixin only works with classes.\u0026quot;);\n    static assert(HasDefaultCtor!ThisType, \u0026quot;This function relies on the class having a default constructor.\u0026quot;);\n\n    public static ThisType deserialise(JSONValue json)\n    {\n        if(json.type == JSONType.null_)\n        {\n            return null;\n        }\n\n        auto instance = new ThisType();\n\n        static foreach(member; ThisType.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = json[MemberName].deserialise!MemberType();\n            mixin(\u0026quot;instance.\u0026quot; ~ MemberName ~ \u0026quot; = memberValue;\u0026quot;);\n        }}\n\n        return instance;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"testing-things-worked\"\u003eTesting things worked\u003c/h2\u003e\n\u003cp\u003eIf we now make use of our deserialiser, it should end up calling our automatically generated \u003ccode\u003edeserialise\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/kUXvzB\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person = new PersonClass(\u0026quot;Bradley\u0026quot;, 21, PersonType.Student);\n    writeln(deserialise!PersonClass(parseJSON(`{ \u0026quot;name\u0026quot;: \u0026quot;Bradley\u0026quot;, \u0026quot;age\u0026quot;: 21, \u0026quot;type\u0026quot;: \u0026quot;Student\u0026quot; }`)));\n}\n\n/*\n    Output:\n        I am Bradley, I am 21 years old, and I'm a Student.\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eEven if this post was quite short and basic, it covers one of the last core features of D's metaprogramming features. The only other core\nfeature I haven't covered are \u003ca href=\"https://dlang.org/spec/template.html#implicit_template_properties\"\u003eeponymous templates\u003c/a\u003e, as I couldn't think\nof a way to fit them into the context of this serialiser.\u003c/p\u003e\n\u003cp\u003eAnyway, I hope the knowledge (and awful writing style!) of this tutorial series will have helped bootstrap your knowledge of D's metaprogramming, aiding\nyou in any future endevors.\u003c/p\u003e\n\u003cp\u003eIf you've enjoyed this series, please share it around to whomever you may think will be interested.\u003c/p\u003e\n\u003cp\u003eIf you have any suggestions or improvements, feel free to either directly propose changes using the \u0026quot;Improve on Github\u0026quot; button below; open an issue on Github, or even just\nemail me. I'm open to changes and criticism.\u003c/p\u003e\n\u003cp\u003eThank you.\u003c/p\u003e\n","title":"Mixin template to automate static deserialise","created":"0001-01-01T00:00:00Z","updated":"0001-01-01T00:00:00Z","seoUrl":"","seoTitle":"","seoDescription":""}