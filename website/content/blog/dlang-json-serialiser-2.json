{"html":"<p>The ability to serialiser basic types is fun and all, but it&apos;s not <em>useful</em>.</p><p>Naturally this means that the next step is to be able to serialise entire structs, which is actually somewhat useful.\nWhile the end result of this serialiser is going to be relatively simple, this series\nof posts should get you started with the knowledge you need to tailor it to your taste.</p><h2 id=\"static-foreach\">static foreach</h2><p>Before we can start with structs there are a few features that need a dedicated explanation. One of these\nfeatures being <code>static foreach</code>.</p><p>A <code>static foreach</code> is a special compile-time-only version of a normal <code>foreach</code>\nloop. Like all compile time constructs, it can only access data that exists at compile time.</p><p>A few things to note about <code>static foreach</code> are:</p><ul><li><p>It does <strong>not</strong> create a scope</p></li></ul><ul><li><p>It is &apos;unrolled&apos; at compile time</p></li></ul><p>If you&apos;re confused about these points, please consider this code:</p><pre><code>void main()\n{\n    import std.stdio : writeln;\n\n    static foreach(number; [1, 2, 3, 4, 5])\n    {\n        writeln(number);\n    }\n}\n</code></pre><p>When I say that a <code>static foreach</code> is &apos;unrolled&apos; it means that the loop\nis executed during compliation, and that the compiler will essentially copy-paste its body for each\niteration of the loop.</p><p>For example, the above example would unroll into the following code:</p><pre><code>void main()\n{\n    import std.stdio : writeln;\n\n    writeln(1);\n    writeln(2);\n    writeln(3);\n    writeln(4);\n    writeln(5);\n}\n</code></pre><p>Now, as I mentioned a <code>static foreach</code> won&apos;t create a scope, which can cause\nissues once we start using variables:</p><pre><code>void main()\n{\n    import std.stdio : writeln;\n\n    static foreach(number; [1, 2, 3])\n    {\n        int veryComplexEquation = number + number;\n        writeln(veryComplextEquation);\n    }\n}\n</code></pre><p>Unrolls to:</p><pre><code>void main()\n{\n    import std.stdio : writeln;\n\n    int veryComplexEquation = 1 + 1;\n    writeln(veryComplextEquation);\n\n    // Error: Redefining variable 'veryComplexEquation'\n    int veryComplexEquation = 2 + 2;\n    writeln(veryComplextEquation);\n\n    // Error: Redefining variable 'veryComplexEquation'\n    int veryComplexEquation = 3 + 3;\n    writeln(veryComplextEquation);\n}\n</code></pre><p>As you can see because we don&apos;t create a scope, and we use a variable inside\nthe <code>static foreach</code>, the variable we use is defined multiple times\nwhich causes a compiler error.</p><p>While in this case we could just define our variable outside the loop, this isn&apos;t\nalways possible/clean to do so we will instead want to create a scope inside each\nunrolling of the <code>static foreach</code>.</p><p>This is blindingly easy, instead of using singular curly braces ({ and }), double\nthem up instead ({{ and }}):</p><pre><code>void main()\n{\n    import std.stdio : writeln;\n\n    static foreach(number; [1, 2, 3])\n    {{\n        int veryComplexEquation = number + number;\n        writeln(veryComplextEquation);\n    }}\n}\n</code></pre><p>Unrolls to:</p><pre><code>void main()\n{\n    import std.stdio : writeln;\n\n    {\n        int veryComplexEquation = 1 + 1;\n        writeln(veryComplextEquation);\n    }\n\n    {\n        int veryComplexEquation = 2 + 2;\n        writeln(veryComplextEquation);\n    }\n\n    {\n        int veryComplexEquation = 3 + 3;\n        writeln(veryComplextEquation);\n    }\n}\n</code></pre><p>And that&apos;s basically all you need to do to create a scope.\nIf it&apos;s not too clear how this is working, put the extra set of curly braces\non their own lines, and it might make more sense. It&apos;s worth noting this is also\nhow you can create a scope with <code>static if</code>.</p><h2 id=\"aliases\">aliases</h2><p>An <code>alias</code> is similar to a <code>typedef</code> from the C/C++ world but\ninstead of defining an entirely new type you, as the name suggests, create an alias to it instead.\nAliases can be used with any symbol (e.g. functions), not just types.</p><pre><code>struct SomeStruct\n{\n    int a;\n}\n\nalias SStruct = SomeStruct;\n\nvoid main()\n{\n    // Since it's just an alias, we can do things like \"set alias to original type\",\n    // because they're literally the same thing.\n    SStruct a = SomeStruct(200);\n}\n</code></pre><h2 id=\"manifest-constants-and-their-ability-to-be-templates\">Manifest constants and their ability to be templates</h2><p>This often seems to confuse people at first, especially those coming from other languages.</p><p>A manifest constant can be seen as an immutable variable that exists only at compile time,\nand that any uses of it inside of runtime portions of the code will cause the constant to duplicate\nits value (&apos;manifest&apos;) every time it is used.</p><p>Manifest constants are defined and used like a normal variable, except they are prefixed\nby <code>enum</code>.</p><pre><code>enum float PI = 3.14;\n\n// Alternatively, let the compiler figure out the type by omitting the type completely.\nenum AGE = 200;\n</code></pre><p>They are a very important and useful in template code as they effectively act as\ncompile-time only variables, and are in fact one of the few ways to store values computed\nat compile time while still allowing things like <code>static if</code> the ability to access them.</p><p>Be warned that there are <a href=\"https://wiki.dlang.org/Declaring_constants#Caveats\">caveats</a> \nto them when arrays are used, due to their nature of duplicating their value.</p><p>One very interesting feature of manifest constants is that they can actually be templates.</p><p>This allows for some interesting usages. For example, the templates we were using from\nstd.traits are all templated enums, which means we could even implement our own versions of templates like\nstd.traits#isBoolean  :</p><pre><code>// I should note that std.traits.isBoolean does a bit more than this\n// but that's besides the point.\nenum myIsBoolean(T) = is(T == bool);\n\nenum isStringABoolean  = myIsBoolean!string; // false\nenum isBooleanABoolean = myIsBoolean!bool;   // true\n\nstatic assert(!isStringABoolean);\nstatic assert(isBooleanABoolean);\n</code></pre><h2 id=\"serialising-a-struct\">Serialising a struct</h2><p>Just as a reminder, here&apos;s our <code>serialise</code> function at the moment. Appreciate its\ncuteness while it lasts:</p><pre><code>JSONValue serialise(T)(T value)\n{\n    return JSONValue(value);\n}\n</code></pre><p>It&apos;s very simple and boring right now, effectively serving as a renamed constructor for <code>JSONValue</code>.\nThat&apos;s going to be changing of course.</p><p>The first thing we want to do is bring in a <code>static if</code> chain, so we\ncan show the user a custom message if they pass in something we can&apos;t handle yet.\nJust like we do with the <code>deserialise</code> function.</p><h3 id=\"serialisation---type-checking\">Serialisation - Type checking</h3><p>At the moment let&apos;s just check if the value is a primitive type (bool, number, or string).</p><p>If we were to just stuff a single <code>static if</code> with all of these checks it&apos;d be\na bit ugly to look at, not to mention annoying to maintain if we needed to reuse the checks\nin another part of the code.</p><p>So instead, let&apos;s create a templated enum to make the code performing these\nchecks cleaner to use.</p><pre><code>enum isPrimitiveType(T) = isNumeric!T || is(T == bool) || is(T == string);\n</code></pre><p>Now, let&apos;s modify our <code>serialise</code> function to spit out an error\nif this check fails:</p><pre><code>enum isPrimitiveType(T) = isNumeric!T || is(T == bool) || is(T == string);\n\nJSONValue serialise(T)(T value)\n{\n    static if(isPrimitiveType!T)\n    {\n        return JSONValue(value);\n    }\n    else\n    {\n        static assert(false, \"Don't know how to serialise type: \" ~ T.stringof);\n    }\n}\n</code></pre><p>Much cleaner than stuffing the all of the type checks into a single <code>static if</code>.</p><h3 id=\"serialisation---iterating-over-a-struct-s-members\">Serialisation - Iterating over a struct&apos;s members</h3><p>To start we&apos;ll a <code>static if</code> for structs, and simply return an empty json value:</p><pre><code>JSONValue serialise(T)(T value)\n{\n    static if(isPrimitiveType!T)\n    { /**/ }\n    else static if(is(T == struct))\n    {\n        JSONValue toReturn;\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n</code></pre><p>Next, we need a struct that we want to test with, so let&apos;s create one:</p><pre><code>struct Person \n{\n    string name;\n    uint age;\n}\n</code></pre><p>The <code>serialise</code> function now requires the ability to inspect each member of the\nstruct, so it can determine what to do with them.</p><p>Structs and classes in D have a special <code>.tupleof</code> property, which returns\na special kind of compile time tuple (think of an immutable array that can contain\ndifferent types of data, including symbols) that contains all of the fields for the\nstruct/class.</p><p>So if we combine <code>.tupleof</code> and <code>static foreach</code> together then we can effectively create \nspecialised code for each member field in the struct.</p><p>To make this more clear we can start off by creating an <code>alias</code> to the\nmember&apos;s type, then use <code>pragma(msg)</code> (akin to a compile-time std.stdio#writeln ) \nto print out the name of the type.</p><pre><code>// https://run.dlang.io/is/NbfZ9i\nJSONValue serialise(T)(T value)\n{\n    /* omitted for brevity */\n    else static if(is(T == struct))\n    {\n        JSONValue toReturn;\n\n        // Note that we're using double braces, so we can have a scope.\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            pragma(msg, MemberType.stringof);\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n</code></pre><p>With the simple output of:</p><pre><code>string\nint\n</code></pre><p>While we now have the type of the member, which we&apos;re not going to use until a bit later,\nwe also want to know the name of the member since otherwise we don&apos;t have a name to store its value with in JSON.</p><p>To do this, we can use one of the special\n<a href=\"https://dlang.org/spec/traits.html\">__traits()</a>\nwhich exposes many different characteristics about symbols.</p><p>For the case of getting the name of something, we can employ the use of\n<a href=\"https://dlang.org/spec/traits.html#identifier\">__traits(identifier)</a>, which when\ngiven a symbol will return its name. This is different from <code>.stringof</code>\nas that only works on types.</p><pre><code>// https://run.dlang.io/is/ptqEnV\nJSONValue serialise(T)(T value)\n{\n    /* omitted for brevity */\n    else static if(is(T == struct))\n    {\n        JSONValue toReturn;\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n\n            // Much like `enum`, the compiler can figure out that the type is a string here\n            const MemberName = __traits(identifier, member);\n\n            pragma(msg, MemberName ~ \" is a \" ~ MemberType.stringof);\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n</code></pre><p>Which outputs:</p><pre><code>name is a string\nage is a int\n</code></pre><h3 id=\"serialisation---serialising-each-member--and-string-mixins\">Serialisation - Serialising each member, and string mixins</h3><p>Now that we have the name, type, and ability\nto iterate each member of a struct, we finally have all the information needed\nto be able to serialise each member into our <code>toReturn</code> value.</p><p>This is a fairly straight forward process: all we need to do is pass each member\nto <code>serialise</code> as that already has all the logic in place,\nand then place the return value into the <code>toReturn</code> value\nwith the member&apos;s name as the key and the return value as the value.</p><p>There&apos;s one thing you might be wondering however - how do I\nactually <em>access</em> the member using the <code>value</code>\nparameter that gets passed to the function.</p><p>The answer here, is to use a string <a href=\"https://dlang.org/articles/mixin.html\">mixin</a>.</p><p>A string mixin is similar to the <code>#define</code> directive in C/C++ land\nin that it can be used to turn a string into code,\nexcept mixins are more limited in where you can place it yet more powerful by the fact\nit uses strings directly.</p><p>So basically, we have our <code>value</code> parameter, and we have the <code>MemberName</code>\nof each member of the value. By combining the two together in a mixin we can\nget access to the member&apos;s value during runtime.</p><pre><code>MemberType memberValue = mixin(\"value.\" ~ MemberName);\n</code></pre><p>Which compiles into:</p><pre><code>// For Person.name\nstring memberValue = value.name;\n\n// For Person.age\nint memberValue = value.age;\n</code></pre><p>Relatively easy, right?</p><p>Anyway, all that&apos;s left to do is to serialise the <code>memberValue</code> and place it\ninto the <code>toReturn</code> value under the member&apos;s name.</p><pre><code>JSONValue serialise(T)(T value)\n{\n    /* omitted for brevity */\n    else static if(is(T == struct))\n    {\n        JSONValue toReturn;\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = mixin(\"value.\" ~ MemberName);\n\n            // toReturn is a JSON object. Use MemberName as the key. Serialise memberValue as the value.\n            toReturn[MemberName] = serialise(memberValue);\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n</code></pre><p>Now comes the time to test it!</p><pre><code>// https://run.dlang.io/is/1WtNd0\nvoid main()\n{\n    import std.stdio;\n    \n    // Instead of specifying the type ourselves as JSONValue, we can\n    // instead use `auto`, which lets the compiler do it for us.\n    auto json = serialise(Person(\"Bradley\", 20));\n    writeln(json);\n\n    /*\n    Output:\n        {\"age\":20,\"name\":\"Bradley\"}\n    */\n}\n</code></pre><p>Success!</p><h2 id=\"deserialising-a-struct\">Deserialising a struct</h2><p>For reference, this is what the <code>deserialise</code> function\nlooks like at the moment:</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    {\n        return json.str;\n    }\n    else static if(is(T == bool))\n    {\n        return json.boolean;\n    }\n    else static if(isFloatingPoint!T)\n    {\n        return json.floating.to!T();\n    }    \n    else static if(isSigned!T)\n    {\n        return json.integer.to!T();\n    }\n    else static if(isUnsigned!T)\n    {\n        return json.uinteger.to!T();\n    }\n    else\n    {\n        static assert(false, \"Don't know how to deserialise type: \" ~ T.stringof);\n    }\n}\n</code></pre><p>To be honest this is pretty much the exact same process, so\nhere&apos;s the code needed for our <code>deserialise</code> function\nand I&apos;ll point out the differences afterwards.</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    /* omitted for brevity */\n    else static if(is(T == struct))\n    {\n        T toReturn;\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = deserialise!MemberType(json[MemberName]);\n\n            // Since the mixin is the *entire* statement, we need to also include a semi-colon in the mixin.\n            mixin(\"toReturn.\" ~ MemberName ~ \" = memberValue;\");\n            // e.g\n            // toReturn.name = memberValue;\n            // toReturn.age = memberValue;\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n</code></pre><p>See how such (relatively) simple concepts (<code>static if/foreach</code>, <code>__traits</code>, <code>mixin</code>, etc.) can be\nbrought together to allow <em>easy yet powerful</em> code generation? This is in my opinion one of D&apos;s main selling points.</p><p>Anyway, here are the main differences:</p><ul><li><p>The type of <code>toReturn</code> is now <code>T</code>, the struct we&apos;re deserialising</p></li></ul><ul><li><p>memberValue uses <code>json[MemberName]</code> to get the JSON version of the value,\nthen calls <code>deserialise</code> to turn it into a <code>MemberType</code></p></li></ul><ul><li><p>We use a string mixin to generate the code to assign the value inside of <code>toReturn</code>\nto the deserialised <code>memberValue</code></p></li></ul><p>Let&apos;s give it a test:</p><pre><code>// https://run.dlang.io/is/nCESzP\nvoid main()\n{\n    import std.stdio : writeln;\n    \n    auto json = serialise(Person(\"Bradley\", 20));\n    writeln(\"As JSON: \", json);\n    \n    // writeln can pretty-print structs thanks to the same features we just used.\n    auto person = deserialise!Person(json);\n    writeln(\"As Person: \", person);\n\n    /*\n    Output:\n        As JSON: {\"age\":20,\"name\":\"Bradley\"}\n        As Person: Person(\"Bradley\", 20)\n    */\n}\n</code></pre><h2 id=\"conclusion\">Conclusion</h2><p>We now have a slightly more useful serialiser due to the newly added\nability to serialise and deserialise structs.</p><p>If the ease and simplicity of what this code can accomplish doesn&apos;t open your eyes\nto the capabilities of D&apos;s metaprogramming, then I advise you to go to a local [D\nshelter](https://forum.dlang.org/) to pet and play with some lonely <strong>D</strong>evelopers ;).</p><h2 id=\"excercises\">Excercises</h2><h3 id=\"excercise--1---more-validation\">Excercise #1 - More validation</h3><p>Fairly similar to the excercise from the previous post.</p><p>Basically, in the <code>deserialise</code> function ensure that the</p><p><code>json</code> value passed to the function is an object, and not something\nlike a string or int.</p><p>Then, before you deserialise a member, check that it actually exists first inside\nof the json value, and throw an exception otherwise.</p><p>You can use the <code>in</code> operator on <code>JSONValues</code>, which\nreturns a pointer, e.g. <code>JSONValue* ptr = (\"name\" in json);</code></p><p>If this pointer is <code>null</code>, then the key doesn&apos;t exist. If it does exist,\nthen you can continue with the deserialisation.</p><p>Like before, while <code>JSONValue</code> will technically do this for you, it&apos;s a good way to\npractice checking for and handling things like this.</p><p>Test case:</p><pre><code>// https://run.dlang.io/is/HhxkdZ\nvoid main()\n{\n    import std.exception : assertThrown, assertNotThrown;\n\n    JSONValue json;\n    json[\"age\"] = JSONValue(200);\n\n    assertThrown(json.deserialise!Person());\n    assertThrown(JSONValue(null).deserialise!Person());\n\n    json[\"name\"] = JSONValue(\"Bradley\");\n    assertNotThrown(json.deserialise!Person());\n}\n</code></pre>","metadata":["dlang-json-serialiser-2","serialise-struct","31-10-2019","Serialising structs","07-02-2020"],"headers":[{"text":"static foreach","slug":"static-foreach","level":2},{"text":"aliases","slug":"aliases","level":2},{"text":"Manifest constants and their ability to be templates","slug":"manifest-constants-and-their-ability-to-be-templates","level":2},{"text":"Serialising a struct","slug":"serialising-a-struct","level":2},{"text":"Serialisation - Type checking","slug":"serialisation---type-checking","level":3},{"text":"Serialisation - Iterating over a struct's members","slug":"serialisation---iterating-over-a-struct-s-members","level":3},{"text":"Serialisation - Serialising each member, and string mixins","slug":"serialisation---serialising-each-member--and-string-mixins","level":3},{"text":"Deserialising a struct","slug":"deserialising-a-struct","level":2},{"text":"Conclusion","slug":"conclusion","level":2},{"text":"Excercises","slug":"excercises","level":2},{"text":"Excercise #1 - More validation","slug":"excercise--1---more-validation","level":3}]}