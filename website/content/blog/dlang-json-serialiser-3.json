{"uid":"dlang-json-serialiser-3","html":"\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSide note: In true D fashion, \u003ca href=\"https://run.dlang.io\"\u003ehttps://run.dlang.io\u003c/a\u003e is broken with no sign of it being fixed (in terms of creating links),\nso from this point on I'll be using \u003ca href=\"https://godbolt.org\"\u003ehttps://godbolt.org\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIn this post we'll cover how to serialise classes and enums, both of which have certain considerations to go over.\u003c/p\u003e\n\u003ch2 id=\"serialising-enums\"\u003eSerialising enums\u003c/h2\u003e\n\u003cp\u003eThe first thing to consider with enums is whether to serialise them via their names\n(e.g. \u003ccode\u003ePersonType.Student\u003c/code\u003e would become \u0026quot;Student\u0026quot;), or to serialise them\nvia their values.\u003c/p\u003e\n\u003cp\u003eThere are pros and cons to both, mostly revolving around enums that are used as bit flags,\nbut for now we're going to serialise them by names and later on provide a way to use either\nnames or values.\u003c/p\u003e\n\u003cp\u003eWe're going to need an enum to work with so let's create a \u003ccode\u003ePersonType\u003c/code\u003e enum\nfor our \u003ccode\u003ePerson\u003c/code\u003e struct from our \u003ca href=\"https://run.dlang.io/is/nCESzP\"\u003eprevious code\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum PersonType\n{\n    Unknown,\n    Student,\n    Staff\n}\n\nstruct Person\n{\n    string name;\n    int age;\n    PersonType type;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"the-issue-with-enums\"\u003eThe issue with enums\u003c/h3\u003e\n\u003cp\u003eThere is one fairly important yet easy to solve issue with enums - they count as both an enum \u003cem\u003eand\u003c/em\u003e their value type.\u003c/p\u003e\n\u003cp\u003eFor example, take our newly made \u003ccode\u003ePersonType\u003c/code\u003e enum. It is just a\nbog standard enum where the value type is an \u003ccode\u003eint\u003c/code\u003e (by default).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ePersonType\u003c/code\u003e enum, due to having a value type of \u003ccode\u003eint\u003c/code\u003e, will actually\n\u003cstrong\u003epass\u003c/strong\u003e a check such as \u003ccode\u003eis(PersonType == int)\u003c/code\u003e and \u003ccode\u003eisNumeric!PersonType\u003c/code\u003e.\nNeedless to say this is a bit of a roadblock due to our decision to serialise by name instead of value.\u003c/p\u003e\n\u003cp\u003eFortunately, this issue is actually super easy to work around. Via \u003ccode\u003eis(T == enum)\u003c/code\u003e we can create\ncode that works/doesn't work specifically for enums.\u003c/p\u003e\n\u003ch3 id=\"upgrading-our-serialise-function\"\u003eUpgrading our serialise function\u003c/h3\u003e\n\u003cp\u003eFor reference, here's the shortened code for the serialise function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum isPrimitiveType(T) = isNumeric!T || is(T == bool) || is(T == string);\n\nJSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == struct))\n    { /* omitted for brevity */ }\n    else\n    { /* omitted for brevity */ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are two options for us to take here:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eModify \u003ccode\u003eisPrimitiveType\u003c/code\u003e so that it ignores enums, then handle enums later on in the function.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHandle enums inside the function \u003cstrong\u003ebefore\u003c/strong\u003e handling primitive types, so enums have a higher 'priority'.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe will in fact be doing both: option #1 for the \u003ccode\u003eserialise\u003c/code\u003e function, and then option #2 for the\n\u003ccode\u003edeserialise\u003c/code\u003e function. This is to demonstrate both options.\u003c/p\u003e\n\u003cp\u003eTo start, we can use \u003ccode\u003e!is(T == enum)\u003c/code\u003e with \u003ccode\u003eisPrimitiveType\u003c/code\u003e so that it will ignore enums:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/_edV5X\nenum isPrimitiveType(T) = !is(T == enum) \u0026amp;\u0026amp; (isNumeric!T || is(T == bool) || is(T == string));    \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext we need to add a \u003ccode\u003estatic if\u003c/code\u003e so we can handle enums, and then turn the enum\nvalue into its name with the help of the ever-so-useful std.conv#to function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    {\n        return JSONValue(value.to!string()); // PersonType.Student -\u0026gt; \u0026quot;Student\u0026quot;, PersonType.Staff -\u0026gt; \u0026quot;Staff\u0026quot;, etc.\n    }\n    else static if(is(T == struct))\n    { /* omitted for brevity */ }\n    else\n    { /* omitted for brevity */ }\n}    \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that if you do something weird such as \u003ccode\u003ecast(PersonType)400\u003c/code\u003e, then\n\u003ccode\u003estd.conv.to\u003c/code\u003e will actually return \u003ccode\u003e\u0026quot;cast(PersonType)400\u0026quot;\u003c/code\u003e, which\nwill cause errors down the line.\u003c/p\u003e\n\u003ch3 id=\"upgrading-our-deserialise-function\"\u003eUpgrading our deserialise function\u003c/h3\u003e\n\u003cp\u003eFor reference, here's the shortened code for the deserialise function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /* omitted for brevity */ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }   \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct))\n    { /**/ }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs I mentioned before, the \u003ccode\u003edeserialise\u003c/code\u003e function is going to handle\nenums before any other type, so that the enum path takes priority over the others.\u003c/p\u003e\n\u003cp\u003eYet again, our lord and savior std.conv#to comes to our rescue as it can convert a string into an enum\nas long as the string has the same name as one of the enum values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    {\n        // \u0026quot;Student\u0026quot; -\u0026gt; PersonType.Student, etc.\n        return json.str.to!T();\n    }\n    else static if(is(T == string))\n    { /* omitted for brevity */ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }   \n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else static if(is(T == struct))\n    { /**/ }\n    else\n    { /**/ }\n}     \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFinally, as usual, we'll give things a quick test:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/f4xTyB\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto json = serialise(PersonType.Student);\n    writeln(json);\n    writeln(json.deserialise!PersonType());\n\n    json = serialise(Person(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student));\n    writeln(json);\n    writeln(json.deserialise!Person());\n\n    /*\n        Output:\n            \u0026quot;Student\u0026quot;\n            Student\n            {\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;}\n            Person(\u0026quot;Bradley\u0026quot;, 20, Student)\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"serialising-classes\"\u003eSerialising classes\u003c/h2\u003e\n\u003cp\u003eSerialising classes is where a lot of the more important decisions come into play, because\nstructs and classes are very different from one another.\u003c/p\u003e\n\u003cp\u003eFor example, while we \u003cem\u003ecould\u003c/em\u003e just treat classes like they're structs, that will only support\na very tiny amount of classes because:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eClasses can be null.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eClasses may not have a reliable way to construct them (more on that later in the post).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eClasses tend to not expose variables directly, but via getters, setters, and other functions.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAnd many other reasons...\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis post will provide a way to handle some of these issues, but in a real project you may\nneed to fine tune how the serialiser works for your own needs as my solutions are going to be\nrelatively basic and therefore, not as robust as they could be.\u003c/p\u003e\n\u003ch3 id=\"treating-classes-as-structs\"\u003eTreating classes as structs\u003c/h3\u003e\n\u003cp\u003eBefore we can start taking on some of the other issues we need to treat the most\nbasic case of simply being able to serialise and deserialise a class' public variables,\nand then build off of that.\u003c/p\u003e\n\u003cp\u003eFor now we'll assume that all classes passed to the serialise function are not-null.\nSo for serialisation we can very simply just modify the \u003ccode\u003estatic if\u003c/code\u003e that checks\nfor a struct, and extend it to also check for a class:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class)) // \u0026lt;-----\n    { /**/ }\n    else\n    { /**/ }\n}   \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will work for extremely simple classes, e.g. if you were to change \u003ccode\u003ePerson\u003c/code\u003e\nto a class it should be able to serialise a non-null instance of it perfectly fine.\u003c/p\u003e\n\u003cp\u003eFor the deserialise function our biggest hurdle is constructing a new instance of the class\nso we can populate its fields. For now, our code will just assume that there is a default constructor\n(e.g. \u003ccode\u003enew MyClass()\u003c/code\u003e works). Also keep in mind that \u003ccode\u003estatic if\u003c/code\u003e does not create a scope:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class)) // Remember to check for a class here as well.\n    {\n        static if(is(T == class))\n        {\n            T toReturn = new T();\n        }\n        else\n        {\n            T toReturn; // Classes default to `null`, so we can't just reuse this line with them.\n        }\n\n        static foreach(member; T.tupleof)\n        {{\n            /**/\n        }}\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs a quick example, change/copy \u003ccode\u003ePerson\u003c/code\u003e to a class, and then we can\ntest if it works:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/EhHVdN\nvoid main()\n{\n    import std.stdio : writeln, writefln;\n\n    // The compiler doesn't generate a helper constructor like with structs,\n    // so we'll do things like this for now.\n    auto p = new Person();\n    p.name = \u0026quot;Bradley\u0026quot;;\n    p.age = 20;\n    p.type = PersonType.Student;\n\n    auto json = p.serialise();\n    writeln(json);\n\n    // writeln can't automatically format a class like with structs.\n    // So either override the `toString` function in a class, or just manually write out the fields.\n    writefln(\u0026quot;Person(%s, %s, %s)\u0026quot;, p.name, p.age, p.type);\n\n    /*\n        Output:\n            {\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;}\n            Person(Bradley, 20, Student)\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"handling-classes-can-be-null\"\u003eHandling 'classes can be null'\u003c/h3\u003e\n\u003cp\u003eRealistically, being able to handle null classes is a mandatory requirement, so\nlet's get that out of the way quickly.\u003c/p\u003e\n\u003cp\u003eFor serialising we can check if the class is null, and if it is then we can return a \u003ccode\u003eJSONValue(null)\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    static if(isPrimitiveType!T)\n    { /* omitted for brevity */ }\n    else static if(is(T == enum))\n    { /**/ }\n    else static if(is(T == struct) || is(T == class))\n    {\n        JSONValue toReturn;\n\n        static if(is(T == class))\n        {\n            if(value is null)\n            {\n                return JSONValue(null);\n            }\n        }\n\n        static foreach(member; T.tupleof)\n        {{\n            /**/\n        }}\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow if we were to pass a null class instance to the \u003ccode\u003eserialise\u003c/code\u003e function\nit would output a \u003ccode\u003enull\u003c/code\u003e in JSON.\u003c/p\u003e\n\u003cp\u003eFor our \u003ccode\u003edeserialise\u003c/code\u003e function it's a very similar process - check if\nthe given JSON value is null, and if it is then return null:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class)) // Remember to check for a class here as well.\n    {\n        static if(is(T == class))\n        {\n            if(json.type == JSONType.null_)\n                return null;\n\n            T toReturn = new T();\n        }\n        else\n        {\n            T toReturn;\n        }\n\n        /**/\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVery simple and very easy to handle, unlike the can of worms we're about to open regarding\nconstruction of a class.\u003c/p\u003e\n\u003cp\u003eBut before we fall into despair over constructing classes, here's a quick test of the null\nhandling (change \u003ccode\u003ePerson\u003c/code\u003e to a class):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/Q8pU7v\nvoid main()\n{\n    import std.stdio : writeln;\n\n    Person p = null;\n    auto json = p.serialise();\n\n    writeln(json);\n    writeln(json.deserialise!Person());\n\n    /*\n        Output:\n            null\n            null\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"handling-classes-may-not-have-a-reliable-way-to-construct-them-with---traitscompiles\"\u003eHandling 'classes may not have a reliable way to construct them' with __traits(compiles)\u003c/h3\u003e\n\u003cp\u003eCurrently, we use the code \u003ccode\u003enew T()\u003c/code\u003e to construct a new instance of a class.\nThis will only work if the class has either no constructors, or a default constructor.\u003c/p\u003e\n\u003cp\u003eAgain, realistically, classes are very likely to have parameterised constructors and are likely\nincapable of supporting a default constructor.\u003c/p\u003e\n\u003cp\u003eJust as a note, this only applies to deserialisation as serialising does not require\nthe construction of objects (well, unless you want it to).\u003c/p\u003e\n\u003cp\u003eThere are many ways you may want to handle this, such as using std.traits#Parameters\nto check and recognise constructors with certain parameter patterns, having\na pre-defined list of constructor parameters that you support, or just\nnot allowing classes that do not contain a default constructor.\u003c/p\u003e\n\u003cp\u003eIn our case we're going to disallow the use of classes that do not contain a default\nconstructor. Fret not though, as we will be exploring one potential workaround soon.\u003c/p\u003e\n\u003cp\u003eBut for now we're going to be creating ourselves a helper template called \u003ccode\u003eHasDefaultCtor\u003c/code\u003e,\nand we'll use that in our \u003ccode\u003edeserialise\u003c/code\u003e function to check if it returns \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOne way we can do this is to check if the exact code of \u003ccode\u003enew T()\u003c/code\u003e can compile,\nwhich we can achieve via another magical form of \u003ccode\u003e__traits()\u003c/code\u003e called\n\u003ca href=\"https://dlang.org/spec/traits.html#compiles\"\u003e__traits(compiles)\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eBy passing in some code as a parameter the compiler will determine if the code will\ncompile or not, and return a \u003ccode\u003ebool\u003c/code\u003e as the result.\u003c/p\u003e\n\u003cp\u003ePlease note that there is a certain annoyance to \u003ccode\u003e__traits(compiles)\u003c/code\u003e when the code\nyou're checking contains a template function, but such quirk is beyond this quick explanation of it.\u003c/p\u003e\n\u003cp\u003eAnyway, by telling the compiler to check if \u003ccode\u003enew T()\u003c/code\u003e works for a given type\nwe can effectively check if the type has a default constructor, and then from there\nwe can use a \u003ccode\u003estatic assert\u003c/code\u003e to display a message to the user:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum HasDefaultCtor(T) = __traits(compiles, new T());\n\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        static if(is(T == class))\n        {\n            static assert(HasDefaultCtor!T, \u0026quot;The class `\u0026quot; ~ T.stringof ~ \u0026quot;` requires a default constructor.\u0026quot;);\n\n            /**/\n        }\n        else\n        {\n        /\t**/\n        }\n\n        /**/\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is an example of the error message:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/NSwveB\n\nclass NoDefaultCtor\n{\n    this(string str){}\n}\n\nvoid main()\n{\n    deserialise!NoDefaultCtor(JSONValue());\n\n    /*\n        Output:\n            .\\temp.d(27): Error: static assert:  \u0026quot;The class `NoDefaultCtor` requires a default constructor.\u0026quot;\n            .\\temp.d(10):        instantiated from here: `deserialise!(NoDefaultCtor)`\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis isn't overly ideal for many reasons but thankfully as we explore the workaround\nwe'll implement something that handles this issue to a somewhat reasonable degree.\u003c/p\u003e\n\u003ch3 id=\"workaround-for-the-constructor-issue-and-the-fact-classes-tend-to-not-expose-variables-directly\"\u003eWorkaround for the constructor issue, and the fact classes tend to not expose variables directly\u003c/h3\u003e\n\u003cp\u003eI'll be brief. I've already gone over the constructor issue; and\nbecause classes usually don't expose variables directly our current behaviour won't work for most\nof them.\u003c/p\u003e\n\u003cp\u003eRegarding the latter issue, there are several ways to handle the issue ranging from directly\ninspecting the names of functions for keywords (e.g. starting with \u0026quot;get\u0026quot; or \u0026quot;set\u0026quot;), looking for\ngetters/setters that use the \u003ccode\u003e@property\u003c/code\u003e attribute, and any other ways suitable\nfor your use cases.\u003c/p\u003e\n\u003cp\u003eThe solution I will be going for is to add support for classes and structs to provide a static\n\u003ccode\u003edeserialise\u003c/code\u003e function. This will serve as a workaround for the constructor issue as this\nis essentially just a special constructor, and will also outsource the task of handling deserialisation\nto the class itself, which \u003cem\u003etechnically\u003c/em\u003e handles the issue of classes not generally exposing variables.\u003c/p\u003e\n\u003cp\u003eA downside of course is that there's more code to be written for classes to support\ndeserialisation, and therefore more technical debt over the long term.\u003c/p\u003e\n\u003cp\u003eWhile you could also just specifically check for a constructor that takes a \u003ccode\u003eJSONValue\u003c/code\u003e,\nI prefer to create specific functions for things like this as I don't like\nthat it'll limit classes from providing a \u003ccode\u003ethis(JSONValue)\u003c/code\u003e constructor for other\npurposes.\u003c/p\u003e\n\u003cp\u003eThe first thing we'll do is create another helper template (similar to \u003ccode\u003eHasDefaultCtor\u003c/code\u003e)\nthat will check for the special \u003ccode\u003edeserialise\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eThis template needs to check for:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eA static function called \u003ccode\u003edeserialise\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe function's return value is the same/compatible type as the class.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe function takes a \u003ccode\u003eJSONValue\u003c/code\u003e as the first parameter.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere are a few ways to do this, however we'll be using the trusty \u003ccode\u003e__traits(compiles)\u003c/code\u003e again:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that the code we're checking is now inside brackets, since we're doing more\nthan a basic function call.\u003c/p\u003e\n\u003cp\u003eWe're using \u003ccode\u003eT.deserialise\u003c/code\u003e to specifically check for a static function\n(or anything that has the same syntax as a static function); we assign the return value\nto a \u003ccode\u003eT obj\u003c/code\u003e to check that the return value is compatible with whatever \u003ccode\u003eT\u003c/code\u003e is;\nthen finally we also check that a \u003ccode\u003eJSONValue\u003c/code\u003e can be passed as the first parameter.\u003c/p\u003e\n\u003cp\u003eNext, in the \u003ccode\u003edeserialise\u003c/code\u003e function, we want to update the \u003ccode\u003estatic assert\u003c/code\u003e\nthat requires classes to have a default constructor to check if the class has either\na default constructor, or a static deserialise function.\u003c/p\u003e\n\u003cp\u003eWe also need to hide the \u003ccode\u003eT toReturn = new T()\u003c/code\u003e line behind\nthe \u003ccode\u003eHasDefaultCtor\u003c/code\u003e check:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    \n\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        static if(is(T == class))\n        {\n            static assert(HasDefaultCtor!T || HasStaticDeserialiseFunc!T, \n                \u0026quot;The class `\u0026quot; ~ T.stringof ~ \u0026quot;` requires a default constructor or a function matching \u0026quot;\n                ~\u0026quot;`static \u0026quot; ~ T.stringof ~ \u0026quot; deserialise(JSONValue)`\u0026quot;\n            ); \n            // e.g. \u0026quot;The class Person requires a default constructor or a function matching `static Person deserialise(JSONValue)`\u0026quot;\n\n            /**/\n\n            static if(HasDefaultCtor!T)\n            {\n                T toReturn = new T();\n            }\n        }\n        /**/\n\n        return toReturn;\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, if the class has a static deserialise function then we want to use that function\nfor deserialisation instead of our other logic. We still want to handle null std.json#JSONValue:JSONValues,\nand we want to disable our other logic as we won't need it due to another issue of having\ncode exist beyond a \u003ccode\u003ereturn\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eTo do this we just need to tactically employ \u003ccode\u003estatic if\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    \n\nT deserialise(T)(JSONValue json)\n{\n    static if(is(T == enum))\n    { /* omitted for brevity */ }\n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        static if(is(T == class))\n        { /* null is still handled here */ }\n        else\n        { /**/ }\n\n        static if(HasStaticDeserialiseFunc!T)\n        {\n            return T.deserialise(json);\n        }\n        else // If we don't disable this other code, then we'll get a \u0026quot;statement not reachable\u0026quot; error.\n        {\n            static foreach(/**/)\n            {{\n                /**/\n            }}\n            return toReturn;\n        }\n    }\n    else\n    { /**/ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo finish off, let's give it a test:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/Xbann8\n\nclass Person\n{\n    private\n    {\n        string name;\n        int age;\n        PersonType type;\n    }\n\n    // No default ctor.\n    this(string name, int age, PersonType type)\n    {\n        this.name = name;\n        this.age = age;\n        this.type = type;\n    }\n\n    static Person deserialise(JSONValue value)\n    {\n        // Classes having to implement this logic themselves is a neccessary burden if you\n        // were to go this route... or is it *wink* (this is a topic for a future post)\n        return new Person(\n            value[\u0026quot;name\u0026quot;].deserialise!string(),\n            value[\u0026quot;age\u0026quot;].deserialise!int(),\n            value[\u0026quot;type\u0026quot;].deserialise!PersonType()\n        );\n    }\n\n    // So that writeln can show us something useful.\n    override string toString()\n    {\n        import std.format : format;\n\n        return format(\u0026quot;Person(%s, %s, %s)\u0026quot;, this.name, this.age, this.type);\n    }\n}\n\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person = new Person(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student);\n    auto json = person.serialise();\n\n    writeln(json);\n\n    person = json.deserialise!Person();\n    writeln(person);\n\n    /*\n        Output:\n            {\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;}\n            Person(Bradley, 20, Student)\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eOur serialiser can now serialise enums by name and has some dodgey support for serialising\nclasses, meaning it's starting to shape up to be at least \u003cem\u003ekind of\u003c/em\u003e useable. Maybe.\nIf you're desperate.\u003c/p\u003e\n\u003cp\u003eThe next thing we'll look into is to serialise arrays and associative arrays.\u003c/p\u003e\n\u003ch2 id=\"excercises\"\u003eExcercises\u003c/h2\u003e\n\u003ch3 id=\"add-support-for-classes-and-structs-to-provide-their-own-serialise-function\"\u003eAdd support for classes and structs to provide their own serialise function\u003c/h3\u003e\n\u003cp\u003eThis might be something I end up doing in a future post, but for now this is a\ngood excercise to practice using \u003ccode\u003e__traits(compiles)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBasically, allow classes and structs to provide a custom \u003ccode\u003eserialise\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eFor the test case to work, the serialise function must match the signature of: \u003ccode\u003eJSONValue serialise()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eAnd here's the test case:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estruct VerySimpleTest\n{\n    string lalafell;\n\n    JSONValue serialise()\n    {\n        JSONValue json;\n\n        json[\u0026quot;lalafell\u0026quot;] = this.lalafell;\n        json[\u0026quot;hidden_secret\u0026quot;] = \u0026quot;Don't be a lalafell please.\u0026quot;;\n\n        return json;\n    }\n}\n\nvoid main()\n{\n    auto json = serialise(VerySimpleTest(\u0026quot;Zuzu\u0026quot;));\n    assert(json[\u0026quot;lalafell\u0026quot;].str == \u0026quot;Zuzu\u0026quot;);\n    assert(json[\u0026quot;hidden_secret\u0026quot;].str == \u0026quot;Don't be a lalafell please.\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\n","title":"Serialising enums and classes","created":"0001-01-01T00:00:00Z","updated":"0001-01-01T00:00:00Z","seoUrl":"","seoTitle":"","seoDescription":""}