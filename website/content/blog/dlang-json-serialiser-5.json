{"uid":"dlang-json-serialiser-5","html":"\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eAt the moment our serialiser is still really basic and rigid, without really any way to customise\nhow it serialises/deserialises our data.\u003c/p\u003e\n\u003cp\u003eSo the topic for this post is to explore using \u003ca href=\"https://dlang.org/spec/attribute.html#uda\"\u003eUDAs\u003c/a\u003e\n(User Defined Attributes) to allow a clean way of customising the functionality of our serialiser.\u003c/p\u003e\n\u003ch2 id=\"basic-usage-of-udas\"\u003eBasic usage of UDAs\u003c/h2\u003e\n\u003cp\u003eA UDA in D can be pretty much anything such as a struct, any primitive type, you can\neven use functions that are executed at compile-time which return a value to be used as a UDA.\u003c/p\u003e\n\u003cp\u003eTo attach a UDA onto something you use the form \u003ccode\u003e@TypeName\u003c/code\u003e,\nand use \u003ca href=\"https://dlang.org/spec/traits.html#getAttributes\"\u003e__traits(getAttributes)\u003c/a\u003e\nto gain access to these UDAs, e.g:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/69d7am\nenum AnEnum{a}\nstruct AStruct{}\nclass AClass{}\n\nint FunctionThatReturnsTheUDAValue(){ return 0; }\n\n@AnEnum\n@AStruct\n@AClass\n@FunctionThatReturnsTheUDAValue\nstruct Test{}\n\nvoid main()\n{\n    import std.traits;\n\n    // __traits(getAttributes) is another special __trait\n    // which returns a tuple of all UDAs on a symbol.\n    static foreach(uda; __traits(getAttributes, Test))\n        pragma(msg, uda);\n\n    /* \n        Output:\n            AnEnum\n            AStruct\n            AClass\n            0\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"how-to-access-udas-on-a-symbol\"\u003eHow to access UDAs on a symbol\u003c/h3\u003e\n\u003cp\u003eThere are a few ways to do this. One way that the above example shows is to use\nthe \u003ca href=\"https://dlang.org/spec/traits.html#getAttributes\"\u003e__traits(getAttributes)\u003c/a\u003e function\nto get a tuple of every UDA on a symbol.\u003c/p\u003e\n\u003cp\u003eWhile \u003ccode\u003e__traits(getAttributes)\u003c/code\u003e is the most flexible way to mess with UDAs, and\nis how the next few templates below are able to function in the first place, it can be a bit\ntoo much of a hassle to work with when all you want to do are simple checks such as \u0026quot;Is this struct marked\n\u003ccode\u003e@Special\u003c/code\u003e\u0026quot;, or \u0026quot;Get me ONLY the \u003ccode\u003e@Special\u003c/code\u003e UDA from this struct\u0026quot;.\u003c/p\u003e\n\u003cp\u003eIn comes std.traits#hasUDA and std.traits#getUDAs.\nSpecial mention to std.traits#getSymbolsByUDA as I won't be using it in this post, but it's still very useful.\nI feel a quick example should be enough of a demonstration of their usage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/Tszj-k\nstruct UsefulUDA\n{\n    string some;\n    int data;\n}\n\nstruct NeverUsedUDA\n{\n}\n\nstruct MultiUDA\n{\n    string data;\n}\n\n@UsefulUDA(\u0026quot;Foo\u0026quot;, 21)\n@MultiUDA(\u0026quot;Use\u0026quot;)\n@MultiUDA(\u0026quot;Me\u0026quot;)\n@(MultiUDA(\u0026quot;Multiple\u0026quot;), MultiUDA(\u0026quot;Times\u0026quot;))\nstruct MyStruct\n{\n\n}\n\nvoid main()\n{\n    import std.traits : hasUDA, getUDAs;\n    import std.stdio  : writeln, write;\n\n    writeln(\u0026quot;Does struct have @UsefulUDA: \u0026quot;, hasUDA!(MyStruct, UsefulUDA));\n    writeln(\u0026quot;What about @NeverUsedUDA:    \u0026quot;, hasUDA!(MyStruct, NeverUsedUDA));\n\n    // Since UDAs can be used multiple times, getUDAs will return a tuple of ALL\n    // UDAs that you ask it for.\n    // So if you only want a single one, you'll have to get the [0]th one.\n    const UsefulUDA useful = getUDAs!(MyStruct, UsefulUDA)[0];\n    writeln(useful);\n\n    // And of course, you can iterate over the results for UDAs that occur multiple times.\n    static foreach(uda; getUDAs!(MyStruct, MultiUDA))\n        write(uda.data, \u0026quot; \u0026quot;);\n\n    /* \n        Output:  \n            Does struct have @UsefulUDA: true\n            What about @NeverUsedUDA:    false\n            const(UsefulUDA)(\u0026quot;Foo\u0026quot;, 21)\n            Use Me Multiple Times \n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing this newly learned magic, we'll be upgrading our serialiser with the following three UDAs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@Ignore\u003c/code\u003e - Completely ignore a field.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@Name\u003c/code\u003e - Set a custom name to serialise a field as.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@ByValue\u003c/code\u003e - Serialise an enum by value, rather than by name.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"creating-the-udas-and-a-struct-to-test-with\"\u003eCreating the UDAs, and a struct to test with\u003c/h2\u003e\n\u003cp\u003eAll of our UDAs will be \u003ccode\u003estructs\u003c/code\u003e as that's just how I roll with UDAs.\u003c/p\u003e\n\u003cp\u003eWe will also need a struct to test our UDAs with, so we'll create a copy of our\n\u003ccode\u003ePerson\u003c/code\u003e struct and give each field a UDA:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estruct ByValue {}\nstruct Ignore {}\n\nstruct Name\n{\n    string name;\n}\n\n// Keep this version of `Person` around, as I'll use it to compare the output between\n// using UDAs, and not using them.\nstruct Person\n{\n    string name;\n    int age;\n    PersonType type;\n}\n\nstruct PersonWithUDAs\n{\n    @Ignore\n    string name;\n\n    @Name(\u0026quot;yearsOld\u0026quot;)\n    int age;\n\n    @ByValue\n    PersonType type;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"implementing-the-ignore-uda\"\u003eImplementing the \u003ccode\u003e@Ignore\u003c/code\u003e UDA\u003c/h2\u003e\n\u003ch3 id=\"serialise-support\"\u003eSerialise support\u003c/h3\u003e\n\u003cp\u003eReference for the current (and relevent parts of) \u003ccode\u003eserialise\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    /* omitted for brevity */\n    else static if(is(T == struct) || is(T == class))\n    {\n        JSONValue toReturn;\n\n        static if(is(T == class))\n        { /**/ }\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = mixin(\u0026quot;value.\u0026quot; ~ MemberName);\n            toReturn[MemberName] = serialise(memberValue);\n        }}\n\n        return toReturn;\n    }\n    /**/\n}    \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYour first thought for implementing \u003ccode\u003e@Ignore\u003c/code\u003e might be to use\n\u003ccode\u003econtinue\u003c/code\u003e if the field has the UDA attached to it.\u003c/p\u003e\n\u003cp\u003eHowever, \u003ccode\u003estatic foreach\u003c/code\u003e and \u003ccode\u003econtinue\u003c/code\u003e don't exactly\nwork well together, or really at all (think about how \u003ccode\u003estatic foreach\u003c/code\u003e works,\nspecifically that it unrolls itself to generate code).\u003c/p\u003e\n\u003cp\u003eI should mention that \u003cem\u003esometimes\u003c/em\u003e you can get rid of a the \u003ccode\u003estatic\u003c/code\u003e part of the\n\u003ccode\u003estatic foreach\u003c/code\u003e while still being able to use and access compile-time features/data, as well as\nhaving \u003ccode\u003econtinue\u003c/code\u003e work as expected.\u003c/p\u003e\n\u003cp\u003eThis is because \u003ccode\u003estatic foreach\u003c/code\u003e is a relatively new feature of D, so back in ye olde times you had\nto use a special \u003ccode\u003estatic-but-not-static foreach\u003c/code\u003e which would only work when using a \u003ccode\u003eforeach\u003c/code\u003e with a\ncompile-time tuple. It does have its own issues though, so I'd adivse to stick with normal \u003ccode\u003estatic foreach\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAnyway, because of \u003ccode\u003econtinue\u003c/code\u003e not working\nthis means we're going to have to be a bit more creative. Basically, we'll lock the last line of the \u003ccode\u003estatic foreach\u003c/code\u003e\n(which performs the actual serialisation) behind a \u003ccode\u003estatic if\u003c/code\u003e that checks whether the field is to be ignored or not:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    /* omitted for brevity */\n    else static if(is(T == struct) || is(T == class))\n    {\n        JSONValue toReturn;\n\n        static if(is(T == class))\n        { /**/ }\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = mixin(\u0026quot;value.\u0026quot; ~ MemberName);\n\n            // An annoying thing to have to do, but worth the gains that static foreach brings us.\n            static if(!hasUDA!(member, Ignore))\n            {\n                toReturn[MemberName] = serialise(memberValue);\n            }\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is a bit of an iffy way to go about things compared to simply being able to \u003ccode\u003econtinue\u003c/code\u003e\nlike in a normal loop, but it does the job.\u003c/p\u003e\n\u003ch3 id=\"deserialise-support\"\u003eDeserialise support\u003c/h3\u003e\n\u003cp\u003eReference of the current \u003ccode\u003edeserialise\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{    \n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        static if(is(T == class))\n        {\n            /**/\n\n            static if(HasDefaultCtor!T)\n            {\n                T toReturn = new T();\n            }\n        }\n        else\n        {\n            T toReturn;\n        }\n\n        static if(HasStaticDeserialiseFunc!T)\n        { /**/ }\n        else\n        {\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                MemberType memberValue = deserialise!MemberType(toReturn[MemberName]);\n\n                mixin(\u0026quot;toReturn.\u0026quot; ~ MemberName ~ \u0026quot; = memberValue;\u0026quot;);\n            }}\n\n            return toReturn;\n        }\n    }\n    /**/\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is pretty much the same deal: lock the code that does the actual deserialisation behind\na \u003ccode\u003estatic if\u003c/code\u003e that checks for the \u003ccode\u003e@Ignore\u003c/code\u003e UDA:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{    \n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        /**/\n        else\n        {\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                static if(!hasUDA!(member, Ignore)) // This can definitely get annoying for larger blocks of code\n                {\n                    MemberType memberValue = deserialise!MemberType(json[MemberName]);\n\n                    mixin(\u0026quot;toReturn.\u0026quot; ~ MemberName ~ \u0026quot; = memberValue;\u0026quot;);\n                }\n            }}\n\n        return toReturn;\n        }\n    }\n    /**/\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"test\"\u003eTest\u003c/h3\u003e\n\u003cp\u003eWhile testing the UDAs, the tests will show the output from both \u003ccode\u003ePerson\u003c/code\u003e and\n\u003ccode\u003ePersonWithUDAs\u003c/code\u003e to make the differences more obvious.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/VYWCjw\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person     = Person(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student);\n    auto personUDA  = PersonWithUDAs(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student);\n    writeln(person.serialise());\n    writeln(personUDA.serialise());\n\n    writeln(person.serialise().deserialise!Person());\n    writeln(personUDA.serialise().deserialise!PersonWithUDAs());\n\n    /* \n        Output:\n            {\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;}\n            {\u0026quot;age\u0026quot;:20,\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;}\n            Person(\u0026quot;Bradley\u0026quot;, 20, Student)\n            PersonWithUDAs(\u0026quot;\u0026quot;, 20, Student)\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see in the JSON output for \u003ccode\u003ePersonWithUDAs\u003c/code\u003e, the \u0026quot;name\u0026quot;\nfield is completely missing, and when we serialise it back into a struct the \u0026quot;name\u0026quot;\nfield is left as \u003ccode\u003estring.init\u003c/code\u003e since we never give it a value.\u003c/p\u003e\n\u003ch2 id=\"implementing-the-name-uda\"\u003eImplementing the \u003ccode\u003e@Name\u003c/code\u003e UDA\u003c/h2\u003e\n\u003ch3 id=\"serialise-support-1\"\u003eSerialise support\u003c/h3\u003e\n\u003cp\u003eAdding support in the \u003ccode\u003eserialise\u003c/code\u003e function isn't anything too\ndifficult. If the field has \u003ccode\u003e@Name\u003c/code\u003e attached to it then\nwe use the string given by that UDA as the value's key, instead of\nusing the field's name.\u003c/p\u003e\n\u003cp\u003eWe will also store the serialised value in its own variable in preparation\nfor the next UDA:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    /* omitted for brevity */\n    else static if(is(T == struct) || is(T == class))\n    {\n        JSONValue toReturn;\n\n        static if(is(T == class))\n        { /**/ }\n\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                MemberType memberValue = mixin(\u0026quot;value.\u0026quot; ~ MemberName);\n\n                static if(!hasUDA!(member, Ignore))\n                {\n                    JSONValue serialised = serialise(memberValue); // Store the value in a variable for future purposes\n\n                    static if(hasUDA!(member, Name)) // Use a custom name if needed.\n                    {\n                        const SerialiseName = getUDAs!(member, Name)[0].name;\n                        toReturn[SerialiseName] = serialised;\n                    }\n                    else // Otherwise just use the field's name.\n                    {\n                        toReturn[MemberName] = serialised;\n                    }\n                }\n            }}\n\n        return toReturn;\n    }\n    /**/\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"deserialise-support-1\"\u003eDeserialise support\u003c/h3\u003e\n\u003cp\u003eAgain this isn't too difficult - we will store the value to deserialise in its own variable and use\n\u003ccode\u003estatic if\u003c/code\u003e to determine whether to use the field's actual name, or\nwhatever name was provided by \u003ccode\u003e@Name\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{    \n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        /**/\n        else\n        {\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                static if(!hasUDA!(member, Ignore))\n                {\n                    static if(hasUDA!(member, Name))\n                    {\n                        const SerialiseName = getUDAs!(member, Name)[0].name; \n                        JSONValue value = json[SerialiseName];\n                    }\n                    else\n                    {\n                        JSONValue value = json[MemberName];\n                    }\n\n                    MemberType memberValue = deserialise!MemberType(value);\n\n                    mixin(\u0026quot;toReturn.\u0026quot; ~ MemberName ~ \u0026quot; = memberValue;\u0026quot;);\n                }\n            }}\n\n            return toReturn;\n        }\n    }\n    /**/\n}    \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"test-1\"\u003eTest\u003c/h3\u003e\n\u003cp\u003eThe testing code is the same as before, but now that we've implemented support for\n\u003ccode\u003e@Name\u003c/code\u003e, the output is a bit different:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/_n6fbB\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person     = Person(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student);\n    auto personUDA  = PersonWithUDAs(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student);\n    writeln(person.serialise());\n    writeln(personUDA.serialise());\n\n    writeln(person.serialise().deserialise!Person());\n    writeln(personUDA.serialise().deserialise!PersonWithUDAs());\n\n    /* \n        Output:\n            {\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;}\n            {\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;,\u0026quot;yearsOld\u0026quot;:20}\n            Person(\u0026quot;Bradley\u0026quot;, 20, Student)\n            PersonWithUDAs(\u0026quot;\u0026quot;, 20, Student)\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJust as we had hoped, the JSON output for \u003ccode\u003ePersonWithUDAs\u003c/code\u003e now uses\n\u0026quot;yearsOld\u0026quot; instead of \u0026quot;age\u0026quot; to store the person's age.\u003c/p\u003e\n\u003ch2 id=\"implementing-the-byvalue-uda\"\u003eImplementing the \u003ccode\u003e@ByValue\u003c/code\u003e UDA\u003c/h2\u003e\n\u003ch3 id=\"serialise-support-2\"\u003eSerialise support\u003c/h3\u003e\n\u003cp\u003eFor serialisation we need to add a \u003ccode\u003estatic if\u003c/code\u003e that checks for the\n\u003ccode\u003e@ByValue\u003c/code\u003e UDA (and for good measure, making sure it's an enum), and\nthen pass the value directly to the constructor of \u003ccode\u003eJSONValue\u003c/code\u003e to serialise its value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJSONValue serialise(T)(T value)\n{    \n    /* omitted for brevity */\n    else static if(is(T == struct) || is(T == class))\n    {\n        /**/\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = mixin(\u0026quot;value.\u0026quot; ~ MemberName);\n\n            static if(!hasUDA!(member, Ignore))\n            {\n                // This is why we started to store the value into its own variable.\n                static if(hasUDA!(member, ByValue) \u0026amp;\u0026amp; is(MemberType == enum))\n                {\n                    JSONValue serialised = JSONValue(memberValue);\n                }\n                else\n                {\n                    JSONValue serialised = serialise(memberValue);\n                }\n\n                static if(hasUDA!(member, Name))\n                {\n                    const SerialiseName = getUDAs!(member, Name)[0].name;\n                    toReturn[SerialiseName] = serialised;\n                }\n                else\n                {\n                    toReturn[MemberName] = serialised;\n                }\n            }\n        }}\n        /**/\n    }\n    /**/\n}  \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"deserialise-support-2\"\u003eDeserialise support\u003c/h3\u003e\n\u003cp\u003eTo finish off with our last UDA, we need to, surprise surprise, use \u003ccode\u003estatic if\u003c/code\u003e\nyet again to check for \u003ccode\u003e@ByValue\u003c/code\u003e and if the field has the UDA\nthen instead of recursively calling the \u003ccode\u003edeserialise\u003c/code\u003e function we will\ninstead directly convert the \u003ccode\u003eJSONValue\u003c/code\u003e into the field's type via the wonderful\nstd.conv#to function.\u003c/p\u003e\n\u003cp\u003eNot only can it convert by name, it can also convert by value!\u003c/p\u003e\n\u003cp\u003eI'd like to note that in D an enum's base type isn't limited to just numeric types\nsuch as \u003ccode\u003eint\u003c/code\u003e or \u003ccode\u003euint\u003c/code\u003e, but to keep things simple we'll just assume that the enum's\nbase type is \u003ccode\u003eint\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eT deserialise(T)(JSONValue json)\n{    \n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        /**/\n        else\n        {\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                static if(!hasUDA!(member, Ignore))\n                {\n                    static if(hasUDA!(member, Name))\n                    {\n                        const SerialiseName = getUDAs!(member, Name)[0].name; \n                        JSONValue value = json[SerialiseName];\n                    }\n                    else\n                    {\n                        JSONValue value = json[MemberName];\n                    }\n\n                    // We can't use `deserialise` again, as that assumes enums are stored by name, as strings.\n                    // So we have to go this route.\n                    static if(hasUDA!(member, ByValue))\n                    {\n                        MemberType memberValue = value.integer.to!MemberType();\n                    }\n                    else\n                    {\n                        MemberType memberValue = deserialise!MemberType(value);\n                    }\n\n                    mixin(\u0026quot;toReturn.\u0026quot; ~ MemberName ~ \u0026quot; = memberValue;\u0026quot;);\n                }\n            }}\n\n            return toReturn;\n        }\n    }\n    /**/\n}    \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"test-2\"\u003eTest\u003c/h3\u003e\n\u003cp\u003eJust like with \u003ccode\u003e@Name\u003c/code\u003e we'll use the same testing code as before, but\nnow that we've implemented \u003ccode\u003e@ByValue\u003c/code\u003e we should get different results:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// https://godbolt.org/z/TXLkMC\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person     = Person(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student);\n    auto personUDA  = PersonWithUDAs(\u0026quot;Bradley\u0026quot;, 20, PersonType.Student);\n    writeln(person.serialise());\n    writeln(personUDA.serialise());\n\n    writeln(person.serialise().deserialise!Person());\n    writeln(personUDA.serialise().deserialise!PersonWithUDAs());\n\n    /* \n        Output:\n            {\u0026quot;age\u0026quot;:20,\u0026quot;name\u0026quot;:\u0026quot;Bradley\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;Student\u0026quot;}\n            {\u0026quot;type\u0026quot;:1,\u0026quot;yearsOld\u0026quot;:20}\n            Person(\u0026quot;Bradley\u0026quot;, 20, Student)\n            PersonWithUDAs(\u0026quot;\u0026quot;, 20, Student)\n    */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd voila: the enum is now stored by its value instead of its name.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eVia the power of UDAs we can now customise to a basic extent the way our serialiser works.\u003c/p\u003e\n\u003cp\u003eOne of the downsides of course is that our single-function \u003ccode\u003eserialise\u003c/code\u003e and\n\u003ccode\u003edeserialise\u003c/code\u003e functions are becoming very unweidly and will continue to do so\nas more and more UDAs are added (e.g. via the excercises below), so I encourage you to\nexperiment with \u003ca href=\"/BlogPost/JsonSerialiser/1\"\u003ea different way\u003c/a\u003e\nof organising these two functions, or just a better way to organise the entire project as a whole.\u003c/p\u003e\n\u003cp\u003eThere will likely be a large gap in time between this post and the next (which may or may not be the last of\nthis series) as I will be improving certain aspects of the website now that I have a few posts to design around,\nputting more time into other projects, etc.\u003c/p\u003e\n\u003cp\u003eIn the meantime I hope this series of posts have provided a decent enough introduction into the\nmyriad of metaprogramming features that D can provide you, to the extent that you're able to recognise the sheer\npower, productivity benefits, and also possibly the downsides that these features can gift you.\u003c/p\u003e\n\u003cp\u003e\u0026quot;With great power comes great responsibilty.\u0026quot;\u003c/p\u003e\n\u003ch2 id=\"excercises\"\u003eExcercises\u003c/h2\u003e\n\u003ch3 id=\"excercise-1---implement-more-udas\"\u003eExcercise #1 - Implement more UDAs\u003c/h3\u003e\n\u003cp\u003eThere won't be a test case for this one, as it completely depends on what UDAs you decide\nto implement.\u003c/p\u003e\n\u003cp\u003eHere are a few ideas:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@MaxLength and @MinLength\u003c/code\u003e - Arrays must have at least/at most a certain length.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@MatchesRegex\u003c/code\u003e - Strings must match the provided regex. (See also std.regex )\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@InRange\u003c/code\u003e - Numeric types must be within/outside/whatever a certain range.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@Description\u003c/code\u003e - Serialisation will output a description for a field. A bit iffy when using JSON, but possible.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@Names\u003c/code\u003e - A list of possible names that the value could be serialised/deserialised as.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e@CaseInsensitive\u003c/code\u003e - A value could be serialised as \u0026quot;KEY\u0026quot; or \u0026quot;kEy\u0026quot; and both would work.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","title":"Using UDAs for customisation","created":"0001-01-01T00:00:00Z","updated":"0001-01-01T00:00:00Z","seoUrl":"","seoTitle":"","seoDescription":""}