{"html":"<p><em>This post is an optional post, meaning you can skip this post without it being\ndetrimental for viewing future posts, and simply exists as an aside &quot;FYI&quot;.</em></p><p>For convenience here&apos;s a shortened version of the <code>deserialise</code>\nfunction that was created in the first post of this series.</p><pre><code>T deserialise(T)(JSONValue json)\n{\n    static if(is(T == string))\n    { /**/ }\n    else static if(is(T == bool))\n    { /**/ }\n    else static if(isFloatingPoint!T)\n    { /**/ }\n    else static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n    else\n    {\n        static assert(false, \"Don't know how to deserialise type: \" ~ T.stringof);\n    }\n}\n</code></pre><p>This kind of &apos;design&apos; being used here is to have a singular template function\n(<code>deserialise</code>) that takes any type as its input, and then leverage <code>static if</code> to determine\nthe actual functionality.</p><p>What if we could write this another way? First, we need to know about template constraints.</p><h2 id=\"template-constraints\">Template constraints</h2><p>Instead of a function that can take any type, imagine that we instead of multiple seperate <em>templated</em> functions that\ncan only take certain types (e.g. only integers, but any kind of integer).</p><p>While we could go the route of nesting a bunch of <code>static ifs</code> inside the function&apos;s body\nfollowed by a <code>static assert</code> should all of these <code>ifs</code> fail, what if instead\nwe tell the compiler the <em>exact</em> conditions needed for it to even consider using the template function?</p><p>I feel an example will help clear things up:</p><pre><code>void someFunc(T)(T value)\nif(is(T == string) || is(T == long))\n{\n    // Do stuff.\n}\n</code></pre><p>So what&apos;s happening here is that we&apos;re creating a template function called <code>someFunc</code>\nwhich takes a type parameter (<code>T</code>), and it does stuff, similar to the other template functions we&apos;ve made so far.</p><p>However, take note that we can actually attach an <code>if</code> statement <em>directly to the function&apos;s signature</em>.\nThis is known as a constraint which you can imagine as a <code>static if</code> that applies for the entire function as a whole.</p><p>The constraint&apos;s condition must pass the given template parameters, otherwise the compiler will refuse to use it for\nthat specific permutation.</p><p>For example:</p><pre><code>// https://run.dlang.io/is/bYQUBq\nvoid main()\n{\n    someFunc!long(200);              // Fine\n    someFunc!string(\"Hello world!\"); // Fine\n    someFunc!bool(false);            // Error (see comment below)\n\n    // The error given is:\n    /*\n    onlineapp.d(5): Error: template instance onlineapp.someFunc!bool does not match template declaration someFunc(T)(T value)\n      with T = bool\n      must satisfy one of the following constraints:\n           is(T == string)\n           is(T == long)\n    */\n}\n\nvoid someFunc(T)(T value)\nif(is(T == string) || is(T == long))\n{\n    import std.stdio : writeln;\n    writeln(T.stringof);\n}\n</code></pre><p>So where am I going with this?</p><h2 id=\"using-constraints-to-create-template-overloads\">Using constraints to create template overloads</h2><p>By using constraints, we can essentially create overloads for template functions.</p><p>Take these two functions for example:</p><pre><code>void someFunc(T)(T value)\nif(is(T == string))\n{\n    // stuff with strings\n}\n\nvoid someFunc(T)(T value)\nif(is(T == long))\n{\n    // stuff with longs\n}\n</code></pre><p>They both have the same name, same template parameters, and same runtime parameters. The\nonly difference are their constraints.</p><p>When calling a template function with overloads like this, the compiler will try to match\neach overload with the parameters that you pass to it (which includes testing the constraints).</p><ul><li><p>If no overloads matches your parameters, the compile fails.</p></li></ul><ul><li><p>If more than one overload matches your parameters, the compile fails due to ambiguity.</p></li></ul><ul><li><p>If exactly one overload matches your parameters, that overload will be used.</p></li></ul><p>So it&apos;s pretty much the same as overloading a non-templated function, except we have more specific\ncontrol on when each overload can be used thanks to constraints.</p><p>What this means is that instead of a singular <code>deserialise</code> function with a bunch\nof <code>static ifs</code>, you could also/instead use seperate overloads for each type\nof data you want to deserialise:</p><pre><code>// For strings\nstring deserialise(T)(JSONValue json)\nif(is(T == string))\n{ /*code here*/ }\n\n// For floats and doubles\nT deserialise(T)(JSONValue json)\nif(isFloatingPoint!T)\n{ /*code here*/ }\n\n// Using both constraints, and static if chains\nT deserialise(T)(JSONValue json)\nif(isIntegral!T)\n{\n    static if(isSigned!T)\n    { /**/ }\n    else static if(isUnsigned!T)\n    { /**/ }\n}\n\n// etc.\n</code></pre><h2 id=\"conclusion\">Conclusion</h2><p>There are pros and cons to both designs, and there are of course more complicated ways/features\nthat can be used to design your code around templates that need to discriminate by things like types.</p><p>However, the main point of this one-off post was just to show and explain a different way\nof doing things, so that it doesn&apos;t seem like a nested web of <code>static ifs</code> is the only\nway to handle something like this.</p><p>D will let you mold your code to the exact vision (or close enough to it) of how you want your API to look\nwithout compromising on maintainability.</p>","metadata":["Template function constraints","dlang-json-serialiser-1-1","template-function-constraints","31-10-2019","Serialising basic D types - Alternative function layout","07-02-2020"],"headers":[{"text":"Template constraints","slug":"template-constraints","level":2},{"text":"Using constraints to create template overloads","slug":"using-constraints-to-create-template-overloads","level":2},{"text":"Conclusion","slug":"conclusion","level":2}]}