{"uid":"dlang-compile-time-text-templates","html":"\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eIn this post we'll be creating a text template format that is capable of running arbitrary D code, and this is all done at compile-time!\u003c/p\u003e\n\u003cp\u003eThis post briefly explains D-specific concepts, so even those that don't know much about D can still read along. Those more familiar with D\nmay not find this post too interesting, but I'd like some feedback via a Github issue if there's anything that can be improved.\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eSome projects may find it useful to be able to define external template files for certain needs such as: project scaffolding, HTML templates,\nor whatever you want really!\u003c/p\u003e\n\u003cp\u003eWhile we can (and will) create a simple \u0026quot;Replace $VAR with string\u0026quot; style of text template, we can actually take things one step further with D -\nwe can allow the template to execute arbitrary D code in order to determine some of its values.\u003c/p\u003e\n\u003cp\u003eWhether this is a good idea or not is completely up to debate, but this is the groundwork required to make things like ASP's Razor templates,\nvibe-d's diet templates, or even just a simple DSL.\u003c/p\u003e\n\u003ch2 id=\"basic-format-and-initial-code-setup\"\u003eBasic format and initial code setup\u003c/h2\u003e\n\u003cp\u003eFirst of all, let's run \u003ccode\u003edub init\u003c/code\u003e to create a new project, and then let's also make a folder called \u0026quot;views\u0026quot;.\u003c/p\u003e\n\u003cp\u003eThe project structure should look something like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/blogs/meta/meta1_project_structure.webp\" alt=\"Project Structure\"\u003e\u003c/p\u003e\n\u003cp\u003eBefore we dive into allowing execution of D code, let's just get the basics done first: Allow the template to define variables, then allow the program\nto fill in those variables with values.\u003c/p\u003e\n\u003cp\u003eTo keep things simple, variables are just strings that we patch into the template's text wherever they're specified.\u003c/p\u003e\n\u003cp\u003eThis will be the example file we're working with, and we'll store this in \u003ccode\u003eviews/template.txt\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDECLARE\n    $NAME\n    $AGE\n    $HOBBIES\nSTART\nMy name is $NAME I am $AGE years old and my hobbies are: $HOBBIES\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow let's open up the \u003ccode\u003esource/app.d\u003c/code\u003e file, and create the initial structure for our program:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003eimport std;\n\nstruct Document\n{\n    string[] declaredVariables;\n    string templateText;\n}\n\nstring resolve(string templateName)(string[string] variables)\n{\n    Appender!(char[]) output;\n\n    return output.data.assumeUnique;\n}\n\nDocument parseDocument(string contents)\n{\n    Document doc;\n\n    return doc;\n}\n\nvoid main()\n{\n    writeln(resolve!\u0026quot;template.txt\u0026quot;(\n    [\n        \u0026quot;$NAME\u0026quot;:    \u0026quot;Bradley\u0026quot;,\n        \u0026quot;$AGE\u0026quot;:     \u0026quot;22\u0026quot;,\n        \u0026quot;$HOBBIES\u0026quot;: \u0026quot;programming, complaining, and long walks at night.\u0026quot;\n    ]));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe start off with \u003ccode\u003eimport std\u003c/code\u003e so we have access to the entire standard library.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eDocument\u003c/code\u003e struct is used to model our template files. For now we simply have the names of any declared variables, and the text that we need to resolve.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eresolve\u003c/code\u003e function will be performing the actual resolution. It takes \u003ccode\u003etemplateName\u003c/code\u003e as a compile-time parameter, and \u003ccode\u003evariables\u003c/code\u003e as a runtime one.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eparseDocument\u003c/code\u003e function will parse the template into a \u003ccode\u003eDocument\u003c/code\u003e struct for us.\u003c/p\u003e\n\u003cp\u003eAnd finally, the \u003ccode\u003emain\u003c/code\u003e function shows how we're going to be using our \u003ccode\u003eresolve\u003c/code\u003e function, and also prints its output for us.\u003c/p\u003e\n\u003cp\u003eYou may have noticed we're using std.array#Appender:Appender, and std.exception#assumeUnique:assumeUnique. You can click on their links\nif you're interested in reading about them as these are more an implementation detail rather than anything crucial.\u003c/p\u003e\n\u003ch2 id=\"implementing-parsedocument\"\u003eImplementing parseDocument\u003c/h2\u003e\n\u003cp\u003eSince the focus of this post is more-so the metaprogramming stuff we'll be doing later, I'll show you the code for\n\u003ccode\u003eparseDocument\u003c/code\u003e, talk about it a bit, and then we'll move on as to not spend too much time here.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003eDocument parseDocument(string contents)\n{\n    enum Mode\n    {\n        none,\n        declare,\n        start\n    }\n\n    Document doc;\n    Mode mode;\n\n    foreach(line; contents.lineSplitter())\n    {\n        switch(mode) with(Mode)\n        {\n            case none:\n                enforce(line == \u0026quot;DECLARE\u0026quot;, \u0026quot;Templates must start with 'DECLARE'\u0026quot;);\n                mode = declare;\n                break;\n\n            case declare:\n                if(line == \u0026quot;START\u0026quot;)\n                {\n                    mode = start;\n                    continue;\n                }\n\n                doc.declaredVariables ~= line.strip(' ');\n                break;\n\n            case start:\n                // This code here is bad, but I wanted to keep things simple.\n                if(doc.templateText.length \u0026gt; 0)\n                    doc.templateText ~= '\\n';\n                doc.templateText ~= line;\n                break;\n\n            default: assert(false);\n        }\n    }\n\n    return doc;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI have decided to use a simple state machine to perform the parsing, whose state is determined by which \u003ccode\u003eMode\u003c/code\u003e it's in.\u003c/p\u003e\n\u003cp\u003eD allows functions to have their own classes, structs, enums, etc. which is very useful for cases like this.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ewith(Mode)\u003c/code\u003e statement allows us to write \u003ccode\u003eMode.none, Mode.declare, etc.\u003c/code\u003e as simply \u003ccode\u003enone, declare, etc.\u003c/code\u003e, which is very nice when paired with \u003ccode\u003eswitch\u003c/code\u003e statements.\u003c/p\u003e\n\u003cp\u003eAlso, here's the documentation for std.exception#enforce if you'd like to read more about it.\u003c/p\u003e\n\u003cp\u003eSo briefly, foreach line within contents:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIf we are not in a mode, ensure that the first line is \u0026quot;DECLARE\u0026quot;, then move into 'declare' mode.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf we are in declare mode and the line is \u0026quot;START\u0026quot;, move into 'start' mode.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf we are in declare mode and the line isn't \u0026quot;START\u0026quot;, trim the spaces from the left and right, and add it into \u003ccode\u003edeclaredVariables\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf we are in start mode then join up all the remaining lines into \u003ccode\u003etemplateText\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"implementing-resolve\"\u003eImplementing resolve\u003c/h2\u003e\n\u003cp\u003eThere's a few things to talk about with this function, but because we haven't implemented allowing templates to execute code yet, I'll do the same thing\nas before:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003estring resolve(string templateName)(string[string] variables)\n{\n    // The types for these two values were made explicit for the user's comfort.\n    // In general, D can infer types automatically in cases like this, so explicit typing is not needed.\n    const string TEMPLATE_CONTENTS = import(templateName);\n    enum Document Doc = parseDocument(TEMPLATE_CONTENTS);\n    enforce(\n        Doc.declaredVariables.all!(varName =\u0026gt; varName in variables), \n        \u0026quot;Not all declared variables were given a value in 'variables'\u0026quot;\n    );\n\n    Appender!(char[]) output;\n\n    string text = Doc.templateText;\n    while(text.length \u0026gt; 0)\n    {\n        const nextVarStart = text.indexOf('$');\n        if(nextVarStart \u0026lt; 0)\n        {\n            output.put(text);\n            break;\n        }\n\n        output.put(text[0..nextVarStart]);\n        text = text[nextVarStart..$];\n\n        const nextSpace = text.indexOfAny(\u0026quot; \\r\\n\u0026quot;);\n        const varName   = (nextSpace \u0026lt; 0) ? text : text[0..nextSpace];\n        text            = (nextSpace \u0026lt; 0) ? null : text[nextSpace..$];\n        output.put(variables[varName]);\n    }\n\n    return output.data.assumeUnique;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo start off, we have the very interesting line of \u003ccode\u003econst string TEMPLATE_CONTENTS = import(templateName)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eRemember how we called one of the folders \u0026quot;views\u0026quot;? This is actually a string import folder that dub automatically tells the compiler about.\nNow remember that in our \u003ccode\u003emain\u003c/code\u003e function we pass in \u003ccode\u003etemplate.txt\u003c/code\u003e as the \u003ccode\u003etemplateName\u003c/code\u003e compile-time parameter?\u003c/p\u003e\n\u003cp\u003eWell, the \u003ccode\u003eimport(string)\u003c/code\u003e statement allows us to directly embed a file from the string import folder into our executable, and access it via\na variable, which is \u003ccode\u003eTEMPLATE_CONTENTS\u003c/code\u003e in this case. So \u003ccode\u003eresolve!\u0026quot;template.txt\u0026quot;\u003c/code\u003e is the user telling us to import the contents of \u003ccode\u003eviews/template.txt\u003c/code\u003e\nso we can process it at compile-time.\u003c/p\u003e\n\u003cp\u003eWe then come to yet another very interesting line: \u003ccode\u003eenum Document Doc = parseDocument(TEMPLATE_CONTENTS);\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAn \u003ccode\u003eenum\u003c/code\u003e value is called a Manifest Constant. It is a value that has no physical location within your executable, and exists purely at compile-time.\nAny usage of an enum value results in it becoming duplicated wherever it is used, kind of like \u003ccode\u003e#define\u003c/code\u003e from C/C++.\u003c/p\u003e\n\u003cp\u003eThe next thing to note is that we're actually setting the value of \u003ccode\u003eDoc\u003c/code\u003e to the return result of \u003ccode\u003eparseDocument\u003c/code\u003e. If you aren't familiar with D,\nthis is called CTFE - Compile Time Function Execution/Evaluation.\u003c/p\u003e\n\u003cp\u003eSo in other words, we're importing the contents of \u003ccode\u003etemplate.txt\u003c/code\u003e, and then parsing it into a \u003ccode\u003eDocument\u003c/code\u003e by executing normal D code, \u003cstrong\u003eall at compile time\u003c/strong\u003e.\nThis is important for when we let templates execute their own code, which we'll start doing very soon.\u003c/p\u003e\n\u003cp\u003eThe rest of this function is basically just replacing all instances of \u003ccode\u003e$NAME\u003c/code\u003e with the value of \u003ccode\u003evariables[\u0026quot;$NAME\u0026quot;]\u003c/code\u003e. You can read through it if you want,\nas I'm not going to explain it line-by-line.\u003c/p\u003e\n\u003ch2 id=\"intermission\"\u003eIntermission\u003c/h2\u003e\n\u003cp\u003eLet's have a quick \u003ccode\u003edub run\u003c/code\u003e of our code, and then move onto the more interesting stuff:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$\u0026gt; dub run\nMy name is Bradley I am 22 years old and my hobbies are: programming, complaining, and long walks at night.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo with our current code we can import templates and do a basic search-and-replace for things like \u003ccode\u003e$NAME\u003c/code\u003e using user-provided values.\u003c/p\u003e\n\u003cp\u003eWe will now add onto our two functions, and also our example file, the ability to compile and run arbitrary D code within our executable.\u003c/p\u003e\n\u003ch2 id=\"final-format\"\u003eFinal format\u003c/h2\u003e\n\u003cp\u003eThe final format for our text templates will look like this. This is also the contents of \u003ccode\u003eviews/template.txt\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDECLARE\n    $NAME\n    $AGE\n    $HOBBIES\nCOMPUTE\n    $HOBBIES_LOUD : variables[\u0026quot;$HOBBIES\u0026quot;].splitter(',').map!(str =\u0026gt; \u0026quot;!!!\u0026quot;~str.strip(' ').toUpper~\u0026quot;!!!\u0026quot;).fold!((a,b) =\u0026gt; a~\u0026quot;, \u0026quot;~b)\nSTART\nMy name is $NAME I am $AGE years old and my hobbies are: $HOBBIES\n\nIf you couldn't hear me loud enough, my hobbies are: $HOBBIES_LOUD\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe have added a new section called \u0026quot;COMPUTE\u0026quot; which contains variables whose values are computed from the specified D code.\u003c/p\u003e\n\u003cp\u003eOur \u003ccode\u003e$HOBBIES_LOUD\u003c/code\u003e variable splits up the \u003ccode\u003e$HOBBIES\u003c/code\u003e variable by comma, adds \u0026quot;!!!\u0026quot; as a suffix and prefix to each word, then turns all words into upper-case\nbefore joining them back together separated by a comma. It's not too important what's there, as long as it's D code, and as long as it evaluates to a \u003ccode\u003estring\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"upgrading-document-and-parsedocument\"\u003eUpgrading Document and parseDocument\u003c/h2\u003e\n\u003cp\u003eWe now need to upgrade \u003ccode\u003eDocument\u003c/code\u003e and \u003ccode\u003eparseDocument\u003c/code\u003e to include our new computed variables. New code is covered in comment lines:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003estruct Document\n{\n    string[] declaredVariables;\n    string templateText;\n\n    /////////////////////////////////\n    // Key is var name, value is D code.\n    string[string] computedVariables;\n    /////////////////////////////////\n}\n\nDocument parseDocument(string contents)\n{\n    enum Mode\n    {\n        none,\n        declare,\n        start,\n\n        ///////\n        compute\n        ///////\n    }\n\n    Document doc;\n    Mode mode;\n\n    foreach(line; contents.lineSplitter())\n    {\n        switch(mode) with(Mode)\n        {\n            case none:\n                enforce(line == \u0026quot;DECLARE\u0026quot;, \u0026quot;Templates must start with 'DECLARE'\u0026quot;);\n                mode = declare;\n                break;\n\n            case declare:\n                if(line == \u0026quot;START\u0026quot;)\n                {\n                    mode = start;\n                    continue;\n                }\n                //////////////////////////\n                else if(line == \u0026quot;COMPUTE\u0026quot;)\n                {\n                    mode = compute;\n                    continue;\n                }\n                //////////////////////////\n\n                doc.declaredVariables ~= line.strip(' ');\n                break;\n\n            ////////////////////////////////////////////////////\n            case compute:\n                if(line == \u0026quot;START\u0026quot;)\n                {\n                    mode = start;\n                    continue;\n                }\n\n                const colon   = line.indexOf(':');\n                const varName = line[0..colon].strip(' ');\n                const code    = line[colon+1..$].strip(' ');\n                doc.computedVariables[varName] = code;\n                break;\n            ////////////////////////////////////////////////////\n\n            case start:\n                // This code here is bad, but I wanted to keep things simple.\n                if(doc.templateText.length \u0026gt; 0)\n                    doc.templateText ~= '\\n';\n                doc.templateText ~= line;\n                break;\n\n            default: assert(false);\n        }\n    }\n\n    return doc;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn short:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eWe add \u003ccode\u003ecomputedVariables\u003c/code\u003e to \u003ccode\u003eDocument\u003c/code\u003e which is a dictionary where the key is the variable's name, and the value is the D code.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe then add a new 'compute' mode for our \u0026quot;COMPUTE\u0026quot; section, which can only be used after the \u0026quot;DECLARE\u0026quot; section.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf we are in 'compute' mode, then split the line by the first colon - everything on the left is the variable name, everything on the right is the D code to execute.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"upgrading-resolve\"\u003eUpgrading resolve\u003c/h2\u003e\n\u003cp\u003eThe ultimate question now is: \u0026quot;How on earth do you let external string files execute D code?\u0026quot;.\u003c/p\u003e\n\u003cp\u003eThis is where the magic happens, and you'll hopefully be shocked (if you're new to D) at how simple this is. We are only adding two lines of code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-d\"\u003estring resolve(string templateName)(string[string] variables)\n{\n    const string TEMPLATE_CONTENTS = import(templateName);\n    enum Document Doc = parseDocument(TEMPLATE_CONTENTS);\n    enforce(\n        Doc.declaredVariables.all!(varName =\u0026gt; varName in variables), \n        \u0026quot;Not all declared variables were given a value in 'variables'\u0026quot;\n    );\n\n    ////////////////////////////////////////////////////\n    static foreach(varName, code; Doc.computedVariables)\n        variables[varName] = mixin(code);\n    ////////////////////////////////////////////////////\n\n    Appender!(char[]) output;\n\n    string text = Doc.templateText;\n    while(text.length \u0026gt; 0)\n    {\n        const nextVarStart = text.indexOf('$');\n        if(nextVarStart \u0026lt; 0)\n        {\n            output.put(text);\n            break;\n        }\n\n        output.put(text[0..nextVarStart]);\n        text = text[nextVarStart..$];\n\n        const nextSpace = text.indexOfAny(\u0026quot; \\r\\n\u0026quot;);\n        const varName   = (nextSpace \u0026lt; 0) ? text : text[0..nextSpace];\n        text            = (nextSpace \u0026lt; 0) ? null : text[nextSpace..$];\n        output.put(variables[varName]);\n    }\n\n    return output.data.assumeUnique;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe first part is that we're making use of \u003ca href=\"https://dlang.org/spec/version.html#staticforeach\"\u003estatic foreach\u003c/a\u003e. Without going into too much\ndetail, it is basically a compile-time \u003ccode\u003eforeach\u003c/code\u003e that duplicates its body into the final code for every value it iterates over. The more technical term is that\nit \u0026quot;unrolls\u0026quot; itself.\u003c/p\u003e\n\u003cp\u003eThe final part is that we're using the statement \u003ccode\u003emixin(code)\u003c/code\u003e. D has a feature called \u003ca href=\"https://tour.dlang.org/tour/en/gems/string-mixins\"\u003estring mixins\u003c/a\u003e which will\ninsert a compile-time string into your code, which is then compiled as you'd expect.\u003c/p\u003e\n\u003cp\u003eRecall that our \u003ccode\u003eenum Document Doc\u003c/code\u003e variable is a compile-time-only value because it is marked as an \u003ccode\u003eenum\u003c/code\u003e. This means we can use the data within this\nvariable directly with compile-time-only constructs such as \u003ccode\u003estatic foreach\u003c/code\u003e and \u003ccode\u003emixin\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSo what our two lines are doing is that they're literally just taking the code from our template file, mixing them into our \u003ccode\u003eresolve\u003c/code\u003e function, and then\nthe result of the code is stored under the variable's name, which the rest of the function will handle for us.\u003c/p\u003e\n\u003cp\u003eLet's have a run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$\u0026gt; dub run\nMy name is Bradley I am 22 years old and my hobbies are: programming, complaining, and long walks at night.\n\nIf you couldn't hear me loud enough, my hobbies are: !!!PROGRAMMING!!!, !!!COMPLAINING!!!, !!!AND LONG WALKS AT NIGHT.!!!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd there you have it. D is amazing at writing code that generates code, and you can see for yourself just how simple things are yet how powerful they are\nwhen you combine all of D's different features together. All without preprocessors or external tooling. All within the same language.\u003c/p\u003e\n\u003cp\u003eNow, if you think about it, you technically know enough to start making things like the \u003ca href=\"https://code.dlang.org/packages/pegged\"\u003epegged\u003c/a\u003e library - translating\na DSL into fully compiled D code for a specific purpose (i.e. parsing from a grammar). All you need to do is translate something into some D code, then \u003ccode\u003emixin\u003c/code\u003e\nsaid code.\u003c/p\u003e\n\u003ch2 id=\"having-some-fun\"\u003eHaving some fun\u003c/h2\u003e\n\u003cp\u003eJust for a bit of fun let's make our template resolve another template. Create another template in \u003ccode\u003eviews/other.txt\u003c/code\u003e and give it these contents:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDECLARE\n    $HOWDY\nSTART\nHOWDY $HOWDY\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow let's update our \u003ccode\u003eviews/template.txt\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDECLARE\n    $NAME\n    $AGE\n    $HOBBIES\nCOMPUTE\n    $HOBBIES_LOUD : variables[\u0026quot;$HOBBIES\u0026quot;].splitter(',').map!(str =\u0026gt; \u0026quot;!!!\u0026quot;~str.strip(' ').toUpper~\u0026quot;!!!\u0026quot;).fold!((a,b) =\u0026gt; a~\u0026quot;, \u0026quot;~b)\n    $MYSELF       : readText(\u0026quot;views/template.txt\u0026quot;)\n    $OTHER        : resolve!(\u0026quot;other.txt\u0026quot;)([\u0026quot;$HOWDY\u0026quot;: \u0026quot;Y'ALL\u0026quot;])\nSTART\nMy name is $NAME I am $AGE years old and my hobbies are: $HOBBIES\n\nIf you couldn't hear me loud enough, my hobbies are: $HOBBIES_LOUD\n\nI can even print myself!\n$MYSELF\n\nAnd even... other templates:\n$OTHER\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd then this gives us the result of:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMy name is Bradley I am 22 years old and my hobbies are: programming, complaining, and long walks at night.\n\nIf you couldn't hear me loud enough, my hobbies are: !!!PROGRAMMING!!!, !!!COMPLAINING!!!, !!!AND LONG WALKS AT NIGHT.!!!\n\nI can even print myself!\n[omitted. Contents of views/template.txt]\n\nAnd even... other templates:\nHOWDY Y'ALL\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eTo conclude, our program from a high-level point of view is:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eImport the contents of a file using D's \u003ccode\u003eimport(string)\u003c/code\u003e statement.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eParse the contents of the file into a struct, stored as a compile-time value, by using D's \u003ca href=\"https://tour.dlang.org/tour/en/gems/compile-time-function-evaluation-ctfe\"\u003eCTFE\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGenerate code for each \u0026quot;compute variable\u0026quot; inside the template using D's \u003ccode\u003estatic foreach\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMixin external/processed strings as code using D's \u003ccode\u003emixin(string)\u003c/code\u003e statement.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDo other faff at runtime that we only slightly care about compared to the above.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI hope this has been interesting for at least a few readers, and this particular blog series is about one-off posts like this that shows how D can be used to\nmake your life just a little bit easier/fancier.\u003c/p\u003e\n","title":"Text templates that can execute code at compile-time","created":"0001-01-01T00:00:00Z","updated":"0001-01-01T00:00:00Z","seoUrl":"","seoTitle":"","seoDescription":""}