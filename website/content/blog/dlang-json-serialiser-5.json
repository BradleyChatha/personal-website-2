{"html":"<p>At the moment our serialiser is still really basic and rigid, without really any way to customise\nhow it serialises/deserialises our data.</p><p>So the topic for this post is to explore using <a href=\"https://dlang.org/spec/attribute.html#uda\">UDAs</a> \n(User Defined Attributes) to allow a clean way of customising the functionality of our serialiser.</p><h2 id=\"basic-usage-of-udas\">Basic usage of UDAs</h2><p>A UDA in D can be pretty much anything such as a struct, any primitive type, you can\neven use functions that are executed at compile-time which return a value to be used as a UDA.</p><p>To attach a UDA onto something you use the form <code>@TypeName</code>,\nand use <a href=\"https://dlang.org/spec/traits.html#getAttributes\">__traits(getAttributes)</a>\nto gain access to these UDAs, e.g:</p><pre><code>// https://godbolt.org/z/69d7am\nenum AnEnum{a}\nstruct AStruct{}\nclass AClass{}\n\nint FunctionThatReturnsTheUDAValue(){ return 0; }\n\n@AnEnum\n@AStruct\n@AClass\n@FunctionThatReturnsTheUDAValue\nstruct Test{}\n\nvoid main()\n{\n    import std.traits;\n\n    // __traits(getAttributes) is another special __trait\n    // which returns a tuple of all UDAs on a symbol.\n    static foreach(uda; __traits(getAttributes, Test))\n        pragma(msg, uda);\n\n    /* \n        Output:\n            AnEnum\n            AStruct\n            AClass\n            0\n    */\n}\n</code></pre><h3 id=\"how-to-access-udas-on-a-symbol\">How to access UDAs on a symbol</h3><p>There are a few ways to do this. One way that the above example shows is to use\nthe <a href=\"https://dlang.org/spec/traits.html#getAttributes\">__traits(getAttributes)</a> function\nto get a tuple of every UDA on a symbol.</p><p>While <code>__traits(getAttributes)</code> is the most flexible way to mess with UDAs, and\nis how the next few templates below are able to function in the first place, it can be a bit\ntoo much of a hassle to work with when all you want to do are simple checks such as &quot;Is this struct marked</p><p><code>@Special</code>&quot;, or &quot;Get me ONLY the <code>@Special</code> UDA from this struct&quot;.</p><p>In comes std.traits#hasUDA and std.traits#getUDAs.\nSpecial mention to std.traits#getSymbolsByUDA as I won&apos;t be using it in this post, but it&apos;s still very useful. \nI feel a quick example should be enough of a demonstration of their usage:</p><pre><code>// https://godbolt.org/z/Tszj-k\nstruct UsefulUDA\n{\n    string some;\n    int data;\n}\n\nstruct NeverUsedUDA\n{\n}\n\nstruct MultiUDA\n{\n    string data;\n}\n\n@UsefulUDA(\"Foo\", 21)\n@MultiUDA(\"Use\")\n@MultiUDA(\"Me\")\n@(MultiUDA(\"Multiple\"), MultiUDA(\"Times\"))\nstruct MyStruct\n{\n\n}\n\nvoid main()\n{\n    import std.traits : hasUDA, getUDAs;\n    import std.stdio  : writeln, write;\n\n    writeln(\"Does struct have @UsefulUDA: \", hasUDA!(MyStruct, UsefulUDA));\n    writeln(\"What about @NeverUsedUDA:    \", hasUDA!(MyStruct, NeverUsedUDA));\n\n    // Since UDAs can be used multiple times, getUDAs will return a tuple of ALL\n    // UDAs that you ask it for.\n    // So if you only want a single one, you'll have to get the [0]th one.\n    const UsefulUDA useful = getUDAs!(MyStruct, UsefulUDA)[0];\n    writeln(useful);\n\n    // And of course, you can iterate over the results for UDAs that occur multiple times.\n    static foreach(uda; getUDAs!(MyStruct, MultiUDA))\n        write(uda.data, \" \");\n\n    /* \n        Output:  \n            Does struct have @UsefulUDA: true\n            What about @NeverUsedUDA:    false\n            const(UsefulUDA)(\"Foo\", 21)\n            Use Me Multiple Times \n    */\n}\n</code></pre><p>Using this newly learned magic, we&apos;ll be upgrading our serialiser with the following three UDAs:</p><ul><li><p><code>@Ignore</code> - Completely ignore a field.</p></li></ul><ul><li><p><code>@Name</code> - Set a custom name to serialise a field as.</p></li></ul><ul><li><p><code>@ByValue</code> - Serialise an enum by value, rather than by name.</p></li></ul><h2 id=\"creating-the-udas--and-a-struct-to-test-with\">Creating the UDAs, and a struct to test with</h2><p>All of our UDAs will be <code>structs</code> as that&apos;s just how I roll with UDAs.</p><p>We will also need a struct to test our UDAs with, so we&apos;ll create a copy of our</p><p><code>Person</code> struct and give each field a UDA:</p><pre><code>struct ByValue {}\nstruct Ignore {}\n\nstruct Name\n{\n    string name;\n}\n\n// Keep this version of `Person` around, as I'll use it to compare the output between\n// using UDAs, and not using them.\nstruct Person\n{\n    string name;\n    int age;\n    PersonType type;\n}\n\nstruct PersonWithUDAs\n{\n    @Ignore\n    string name;\n\n    @Name(\"yearsOld\")\n    int age;\n\n    @ByValue\n    PersonType type;\n}\n</code></pre><h2 id=\"implementing-the---ignore--uda\">Implementing the <code>@Ignore</code> UDA</h2><h3 id=\"serialise-support\">Serialise support</h3><p>Reference for the current (and relevent parts of) <code>serialise</code> function:</p><pre><code>JSONValue serialise(T)(T value)\n{    \n    /* omitted for brevity */\n    else static if(is(T == struct) || is(T == class))\n    {\n        JSONValue toReturn;\n\n        static if(is(T == class))\n        { /**/ }\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = mixin(\"value.\" ~ MemberName);\n            toReturn[MemberName] = serialise(memberValue);\n        }}\n\n        return toReturn;\n    }\n    /**/\n}    \n</code></pre><p>Your first thought for implementing <code>@Ignore</code> might be to use</p><p><code>continue</code> if the field has the UDA attached to it.</p><p>However, <code>static foreach</code> and <code>continue</code> don&apos;t exactly\nwork well together, or really at all (think about how <code>static foreach</code> works,\nspecifically that it unrolls itself to generate code).</p><p>I should mention that <em>sometimes</em> you can get rid of a the <code>static</code> part of the</p><p><code>static foreach</code> while still being able to use and access compile-time features/data, as well as \nhaving <code>continue</code> work as expected.</p><p>This is because <code>static foreach</code> is a relatively new feature of D, so back in ye olde times you had\nto use a special <code>static-but-not-static foreach</code> which would only work when using a <code>foreach</code> with a\ncompile-time tuple. It does have its own issues though, so I&apos;d adivse to stick with normal <code>static foreach</code>.</p><p>Anyway, because of <code>continue</code> not working\nthis means we&apos;re going to have to be a bit more creative. Basically, we&apos;ll lock the last line of the <code>static foreach</code> \n(which performs the actual serialisation) behind a <code>static if</code> that checks whether the field is to be ignored or not:</p><pre><code>JSONValue serialise(T)(T value)\n{    \n    /* omitted for brevity */\n    else static if(is(T == struct) || is(T == class))\n    {\n        JSONValue toReturn;\n\n        static if(is(T == class))\n        { /**/ }\n\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = mixin(\"value.\" ~ MemberName);\n\n            // An annoying thing to have to do, but worth the gains that static foreach brings us.\n            static if(!hasUDA!(member, Ignore))\n            {\n                toReturn[MemberName] = serialise(memberValue);\n            }\n        }}\n\n        return toReturn;\n    }\n    /**/\n}\n</code></pre><p>This is a bit of an iffy way to go about things compared to simply being able to <code>continue</code>\nlike in a normal loop, but it does the job.</p><h3 id=\"deserialise-support\">Deserialise support</h3><p>Reference of the current <code>deserialise</code> function:</p><pre><code>T deserialise(T)(JSONValue json)\n{    \n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        static if(is(T == class))\n        {\n            /**/\n\n            static if(HasDefaultCtor!T)\n            {\n                T toReturn = new T();\n            }\n        }\n        else\n        {\n            T toReturn;\n        }\n\n        static if(HasStaticDeserialiseFunc!T)\n        { /**/ }\n        else\n        {\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                MemberType memberValue = deserialise!MemberType(toReturn[MemberName]);\n\n                mixin(\"toReturn.\" ~ MemberName ~ \" = memberValue;\");\n            }}\n\n            return toReturn;\n        }\n    }\n    /**/\n}\n</code></pre><p>This is pretty much the same deal: lock the code that does the actual deserialisation behind\na <code>static if</code> that checks for the <code>@Ignore</code> UDA:</p><pre><code>T deserialise(T)(JSONValue json)\n{    \n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        /**/\n        else\n        {\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                static if(!hasUDA!(member, Ignore)) // This can definitely get annoying for larger blocks of code\n                {\n                    MemberType memberValue = deserialise!MemberType(json[MemberName]);\n\n                    mixin(\"toReturn.\" ~ MemberName ~ \" = memberValue;\");\n                }\n            }}\n\n        return toReturn;\n        }\n    }\n    /**/\n}\n</code></pre><h3 id=\"test\">Test</h3><p>While testing the UDAs, the tests will show the output from both <code>Person</code> and</p><p><code>PersonWithUDAs</code> to make the differences more obvious.</p><pre><code>// https://godbolt.org/z/VYWCjw\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person     = Person(\"Bradley\", 20, PersonType.Student);\n    auto personUDA  = PersonWithUDAs(\"Bradley\", 20, PersonType.Student);\n    writeln(person.serialise());\n    writeln(personUDA.serialise());\n\n    writeln(person.serialise().deserialise!Person());\n    writeln(personUDA.serialise().deserialise!PersonWithUDAs());\n\n    /* \n        Output:\n            {\"age\":20,\"name\":\"Bradley\",\"type\":\"Student\"}\n            {\"age\":20,\"type\":\"Student\"}\n            Person(\"Bradley\", 20, Student)\n            PersonWithUDAs(\"\", 20, Student)\n    */\n}\n</code></pre><p>As you can see in the JSON output for <code>PersonWithUDAs</code>, the &quot;name&quot;\nfield is completely missing, and when we serialise it back into a struct the &quot;name&quot;\nfield is left as <code>string.init</code> since we never give it a value.</p><h2 id=\"implementing-the---name--uda\">Implementing the <code>@Name</code> UDA</h2><h3 id=\"serialise-support\">Serialise support</h3><p>Adding support in the <code>serialise</code> function isn&apos;t anything too\ndifficult. If the field has <code>@Name</code> attached to it then\nwe use the string given by that UDA as the value&apos;s key, instead of\nusing the field&apos;s name.</p><p>We will also store the serialised value in its own variable in preparation\nfor the next UDA:</p><pre><code>JSONValue serialise(T)(T value)\n{    \n    /* omitted for brevity */\n    else static if(is(T == struct) || is(T == class))\n    {\n        JSONValue toReturn;\n\n        static if(is(T == class))\n        { /**/ }\n\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                MemberType memberValue = mixin(\"value.\" ~ MemberName);\n\n                static if(!hasUDA!(member, Ignore))\n                {\n                    JSONValue serialised = serialise(memberValue); // Store the value in a variable for future purposes\n\n                    static if(hasUDA!(member, Name)) // Use a custom name if needed.\n                    {\n                        const SerialiseName = getUDAs!(member, Name)[0].name;\n                        toReturn[SerialiseName] = serialised;\n                    }\n                    else // Otherwise just use the field's name.\n                    {\n                        toReturn[MemberName] = serialised;\n                    }\n                }\n            }}\n\n        return toReturn;\n    }\n    /**/\n}\n</code></pre><h3 id=\"deserialise-support\">Deserialise support</h3><p>Again this isn&apos;t too difficult - we will store the value to deserialise in its own variable and use</p><p><code>static if</code> to determine whether to use the field&apos;s actual name, or\nwhatever name was provided by <code>@Name</code>.</p><pre><code>T deserialise(T)(JSONValue json)\n{    \n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        /**/\n        else\n        {\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                static if(!hasUDA!(member, Ignore))\n                {\n                    static if(hasUDA!(member, Name))\n                    {\n                        const SerialiseName = getUDAs!(member, Name)[0].name; \n                        JSONValue value = json[SerialiseName];\n                    }\n                    else\n                    {\n                        JSONValue value = json[MemberName];\n                    }\n\n                    MemberType memberValue = deserialise!MemberType(value);\n\n                    mixin(\"toReturn.\" ~ MemberName ~ \" = memberValue;\");\n                }\n            }}\n\n            return toReturn;\n        }\n    }\n    /**/\n}    \n</code></pre><h3 id=\"test\">Test</h3><p>The testing code is the same as before, but now that we&apos;ve implemented support for</p><p><code>@Name</code>, the output is a bit different:</p><pre><code>// https://godbolt.org/z/_n6fbB\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person     = Person(\"Bradley\", 20, PersonType.Student);\n    auto personUDA  = PersonWithUDAs(\"Bradley\", 20, PersonType.Student);\n    writeln(person.serialise());\n    writeln(personUDA.serialise());\n\n    writeln(person.serialise().deserialise!Person());\n    writeln(personUDA.serialise().deserialise!PersonWithUDAs());\n\n    /* \n        Output:\n            {\"age\":20,\"name\":\"Bradley\",\"type\":\"Student\"}\n            {\"type\":\"Student\",\"yearsOld\":20}\n            Person(\"Bradley\", 20, Student)\n            PersonWithUDAs(\"\", 20, Student)\n    */\n}\n</code></pre><p>Just as we had hoped, the JSON output for <code>PersonWithUDAs</code> now uses\n&quot;yearsOld&quot; instead of &quot;age&quot; to store the person&apos;s age.</p><h2 id=\"implementing-the---byvalue--uda\">Implementing the <code>@ByValue</code> UDA</h2><h3 id=\"serialise-support\">Serialise support</h3><p>For serialisation we need to add a <code>static if</code> that checks for the</p><p><code>@ByValue</code> UDA (and for good measure, making sure it&apos;s an enum), and\nthen pass the value directly to the constructor of <code>JSONValue</code> to serialise its value:</p><pre><code>JSONValue serialise(T)(T value)\n{    \n    /* omitted for brevity */\n    else static if(is(T == struct) || is(T == class))\n    {\n        /**/\n        static foreach(member; T.tupleof)\n        {{\n            alias MemberType = typeof(member);\n            const MemberName = __traits(identifier, member);\n\n            MemberType memberValue = mixin(\"value.\" ~ MemberName);\n\n            static if(!hasUDA!(member, Ignore))\n            {\n                // This is why we started to store the value into its own variable.\n                static if(hasUDA!(member, ByValue) && is(MemberType == enum))\n                {\n                    JSONValue serialised = JSONValue(memberValue);\n                }\n                else\n                {\n                    JSONValue serialised = serialise(memberValue);\n                }\n\n                static if(hasUDA!(member, Name))\n                {\n                    const SerialiseName = getUDAs!(member, Name)[0].name;\n                    toReturn[SerialiseName] = serialised;\n                }\n                else\n                {\n                    toReturn[MemberName] = serialised;\n                }\n            }\n        }}\n        /**/\n    }\n    /**/\n}  \n</code></pre><h3 id=\"deserialise-support\">Deserialise support</h3><p>To finish off with our last UDA, we need to, surprise surprise, use <code>static if</code>\nyet again to check for <code>@ByValue</code> and if the field has the UDA\nthen instead of recursively calling the <code>deserialise</code> function we will\ninstead directly convert the <code>JSONValue</code> into the field&apos;s type via the wonderful\nstd.conv#to function.</p><p>Not only can it convert by name, it can also convert by value!</p><p>I&apos;d like to note that in D an enum&apos;s base type isn&apos;t limited to just numeric types\nsuch as <code>int</code> or <code>uint</code>, but to keep things simple we&apos;ll just assume that the enum&apos;s\nbase type is <code>int</code>.</p><pre><code>T deserialise(T)(JSONValue json)\n{    \n    /**/\n    else static if(is(T == struct) || is(T == class))\n    {\n        /**/\n        else\n        {\n            static foreach(member; T.tupleof)\n            {{\n                alias MemberType = typeof(member);\n                const MemberName = __traits(identifier, member);\n\n                static if(!hasUDA!(member, Ignore))\n                {\n                    static if(hasUDA!(member, Name))\n                    {\n                        const SerialiseName = getUDAs!(member, Name)[0].name; \n                        JSONValue value = json[SerialiseName];\n                    }\n                    else\n                    {\n                        JSONValue value = json[MemberName];\n                    }\n\n                    // We can't use `deserialise` again, as that assumes enums are stored by name, as strings.\n                    // So we have to go this route.\n                    static if(hasUDA!(member, ByValue))\n                    {\n                        MemberType memberValue = value.integer.to!MemberType();\n                    }\n                    else\n                    {\n                        MemberType memberValue = deserialise!MemberType(value);\n                    }\n\n                    mixin(\"toReturn.\" ~ MemberName ~ \" = memberValue;\");\n                }\n            }}\n\n            return toReturn;\n        }\n    }\n    /**/\n}    \n</code></pre><h3 id=\"test\">Test</h3><p>Just like with <code>@Name</code> we&apos;ll use the same testing code as before, but\nnow that we&apos;ve implemented <code>@ByValue</code> we should get different results:</p><pre><code>// https://godbolt.org/z/TXLkMC\nvoid main()\n{\n    import std.stdio : writeln;\n\n    auto person     = Person(\"Bradley\", 20, PersonType.Student);\n    auto personUDA  = PersonWithUDAs(\"Bradley\", 20, PersonType.Student);\n    writeln(person.serialise());\n    writeln(personUDA.serialise());\n\n    writeln(person.serialise().deserialise!Person());\n    writeln(personUDA.serialise().deserialise!PersonWithUDAs());\n\n    /* \n        Output:\n            {\"age\":20,\"name\":\"Bradley\",\"type\":\"Student\"}\n            {\"type\":1,\"yearsOld\":20}\n            Person(\"Bradley\", 20, Student)\n            PersonWithUDAs(\"\", 20, Student)\n    */\n}\n</code></pre><p>And voila: the enum is now stored by its value instead of its name.</p><h2 id=\"conclusion\">Conclusion</h2><p>Via the power of UDAs we can now customise to a basic extent the way our serialiser works.</p><p>One of the downsides of course is that our single-function <code>serialise</code> and</p><p><code>deserialise</code> functions are becoming very unweidly and will continue to do so\nas more and more UDAs are added (e.g. via the excercises below), so I encourage you to\nexperiment with <a href=\"/BlogPost/JsonSerialiser/1\">a different way</a>\nof organising these two functions, or just a better way to organise the entire project as a whole.</p><p>There will likely be a large gap in time between this post and the next (which may or may not be the last of\nthis series) as I will be improving certain aspects of the website now that I have a few posts to design around,\nputting more time into other projects, etc.</p><p>In the meantime I hope this series of posts have provided a decent enough introduction into the\nmyriad of metaprogramming features that D can provide you, to the extent that you&apos;re able to recognise the sheer\npower, productivity benefits, and also possibly the downsides that these features can gift you.</p><p>&quot;With great power comes great responsibilty.&quot;</p><h2 id=\"excercises\">Excercises</h2><h3 id=\"excercise--1---implement-more-udas\">Excercise #1 - Implement more UDAs</h3><p>There won&apos;t be a test case for this one, as it completely depends on what UDAs you decide\nto implement.</p><p>Here are a few ideas:</p><ul><li><p><code>@MaxLength and @MinLength</code> - Arrays must have at least/at most a certain length.</p></li></ul><ul><li><p><code>@MatchesRegex</code> - Strings must match the provided regex. (See also std.regex )</p></li></ul><ul><li><p><code>@InRange</code> - Numeric types must be within/outside/whatever a certain range.</p></li></ul><ul><li><p><code>@Description</code> - Serialisation will output a description for a field. A bit iffy when using JSON, but possible.</p></li></ul><ul><li><p><code>@Names</code> - A list of possible names that the value could be serialised/deserialised as.</p></li></ul><ul><li><p><code>@CaseInsensitive</code> - A value could be serialised as &quot;KEY&quot; or &quot;kEy&quot; and both would work.</p></li></ul>","metadata":["dlang-json-serialiser-5","uda-customise-at-sign","31-10-2019","Using UDAs for customisation","07-02-2020"],"headers":[{"text":"Basic usage of UDAs","slug":"basic-usage-of-udas","level":2},{"text":"How to access UDAs on a symbol","slug":"how-to-access-udas-on-a-symbol","level":3},{"text":"Creating the UDAs, and a struct to test with","slug":"creating-the-udas--and-a-struct-to-test-with","level":2},{"text":"Implementing the `@Ignore` UDA","slug":"implementing-the---ignore--uda","level":2},{"text":"Serialise support","slug":"serialise-support","level":3},{"text":"Deserialise support","slug":"deserialise-support","level":3},{"text":"Test","slug":"test","level":3},{"text":"Implementing the `@Name` UDA","slug":"implementing-the---name--uda","level":2},{"text":"Serialise support","slug":"serialise-support","level":3},{"text":"Deserialise support","slug":"deserialise-support","level":3},{"text":"Test","slug":"test","level":3},{"text":"Implementing the `@ByValue` UDA","slug":"implementing-the---byvalue--uda","level":2},{"text":"Serialise support","slug":"serialise-support","level":3},{"text":"Deserialise support","slug":"deserialise-support","level":3},{"text":"Test","slug":"test","level":3},{"text":"Conclusion","slug":"conclusion","level":2},{"text":"Excercises","slug":"excercises","level":2},{"text":"Excercise #1 - Implement more UDAs","slug":"excercise--1---implement-more-udas","level":3}]}